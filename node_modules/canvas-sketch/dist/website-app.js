require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({199:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/** @jsx h */
var Router = require('preact-router');

var _require = require('preact'),
    h = _require.h,
    render = _require.render;

var _require2 = require('preact-router/match'),
    Link = _require2.Link;

var Canvas = require('./components/Canvas');

var Examples = require('./components/Examples');

var gitHubUrl = 'https://github.com/mattdesl/canvas-sketch';
var gitHubUrlDocs = 'https://github.com/mattdesl/canvas-sketch/blob/master/docs/README.md';

var Navbar = function Navbar() {
  return h("div", {
    className: "top-nav"
  }, h("header", null, h(Link, {
    href: "/",
    className: "title"
  }, "canvas-sketch"), h("nav", null, h(Link, {
    activeClassName: "active",
    href: "/examples"
  }, "examples"), h("a", {
    target: "_blank",
    href: gitHubUrlDocs,
    className: "external"
  }, "docs"), h("a", {
    target: "_blank",
    href: gitHubUrl,
    className: "external"
  }, "code"))));
};

var Footer = function Footer() {
  return h("footer", null, h("div", {
    className: "rotated-brief"
  }, "a toolkit for generative art"), h("hr", {
    className: "right"
  }));
};

var Home = function Home() {
  return h("main", {
    className: "landing"
  }, h("p", null, h("strong", null, "canvas-sketch"), " is a loose collection of tools, modules, and resources for creating generative art in JavaScript and the browser."), h("p", null, "It can be used to render high-quality PNG images for Gicl\xE9e prints, create real-time web graphics (such as this page's background), export image sequences for GIF and MP4 loops, generate SVG files for pen plotters (like AxiDraw), automatically git hash your artworks for long-term archiving, and more."), h("p", null, "To get started, check out the ", h("a", {
    target: "_blank",
    href: gitHubUrlDocs
  }, "documentation"), ", or browse through ", h(Link, {
    href: "/examples"
  }, "some examples"), ", or view the ", h("a", {
    target: "_blank",
    href: gitHubUrl
  }, "source code"), " on GitHub."));
};

var Docs = function Docs() {
  return h("main", null, "Docs...");
};

var Content =
/*#__PURE__*/
function (_Router) {
  _inherits(Content, _Router);

  function Content() {
    _classCallCheck(this, Content);

    return _possibleConstructorReturn(this, _getPrototypeOf(Content).apply(this, arguments));
  }

  _createClass(Content, [{
    key: "render",
    value: function render(props, state) {
      var isHome = state.url === '/';
      return h("div", {
        className: "content-layer"
      }, h(Canvas, {
        active: isHome
      }), h(Navbar, null), _get(_getPrototypeOf(Content.prototype), "render", this).call(this, props, state), isHome && h(Footer, null));
    }
  }]);

  return Content;
}(Router);

var App = function App(props, context) {
  return h("div", {
    className: "app"
  }, h(Content, null, h(Home, {
    path: "/"
  }), h(Examples, {
    path: "/examples/:name?"
  })));
};

render(h(App, null), document.body);

},{"./components/Canvas":193,"./components/Examples":194,"preact":166,"preact-router":164,"preact-router/match":165}],194:[function(require,module,exports){
"use strict";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/** @jsx h */
var classnames = require('classnames');

var _require = require('preact-router'),
    route = _require.route;

var _require2 = require('preact'),
    h = _require2.h,
    Component = _require2.Component;

var _require3 = require('preact-router/match'),
    Link = _require3.Link;

var _require4 = require('../data'),
    examples = _require4.examples;

var cachedSource = {};

var getSource = function getSource(name) {
  var url = "/examples/".concat(name, ".js");
  if (url in cachedSource) return cachedSource[url];
  var p = window.fetch(url).then(function (resp) {
    return resp.text();
  });
  cachedSource[url] = p;
  return p;
};

var ExampleItem = function ExampleItem(props) {
  var baseUrl = '/examples';
  var url = "".concat(baseUrl, "/").concat(props.name);
  return h("li", null, h(Link, {
    activeClassName: "active",
    href: url
  }, props.title));
};

var View =
/*#__PURE__*/
function (_Component) {
  _inherits(View, _Component);

  function View(props) {
    var _this;

    _classCallCheck(this, View);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(View).call(this, props));
    _this.state = {
      loading: false,
      code: ''
    };
    return _this;
  }

  _createClass(View, [{
    key: "loadSketch",
    value: function loadSketch(props) {
      var _this2 = this;

      var name = props.name; // If we have a name, start loading

      var loading = Boolean(name);
      this.setState({
        loading: loading,
        code: ''
      });
      getSource(name).then(function (code) {
        _this2.setState({
          loading: false,
          code: code
        });
      });
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(props, state) {
      this.loadSketch(props);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.loadSketch(this.props);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      if (this.element && window.hljs && this.state.code && this.element.parentElement) {
        this.element.innerHTML = this.state.code;
        window.hljs.highlightBlock(this.element.parentElement);
      }
    }
  }, {
    key: "render",
    value: function render(props) {
      var _this3 = this;

      var name = props.name; // User selected an example

      if (name) {
        if (name in examples.map) {
          // Sketch exists!
          var code = this.state.code;

          if (code) {
            var sketch = examples.map[name];
            var classes = classnames('code', {
              loading: !code
            });
            return h("div", {
              className: "sketch-view"
            }, h("iframe", {
              className: "sketch",
              src: "examples/build/".concat(sketch.name, ".html"),
              width: "100%",
              height: "100%"
            }), h("div", {
              className: classes
            }, h("pre", null, h("code", {
              className: "js",
              ref: function ref(c) {
                _this3.element = c;
              }
            }))));
          } else {
            return h("div", {
              className: "sketch-view no-sketch"
            }, h("p", null, "loading"));
          }
        } else {
          // Sketch doesn't exist
          console.warn("Could not find example by id ".concat(name));
          return h("div", {
            className: "sketch-view no-sketch"
          }, h("p", null, "No sketch found by the name ", h("strong", null, name), ","), h("p", null, "try choosing a different one from the list"));
        }
      }

      return h("div", {
        className: "sketch-view no-sketch"
      }, h("p", null, "Choose a sketch from the list to begin."));
    }
  }]);

  return View;
}(Component);

module.exports = function (props, context) {
  var sections = examples.data.map(function (section) {
    if (!section.name) throw new Error('Missing "name" field in section from examples-data.json');
    var itemData = section.items || [];
    var items = itemData.filter(function (d) {
      return d.visible !== false;
    }).map(function (data) {
      return h(ExampleItem, _extends({}, data, {
        name: data.name
      }));
    });
    if (items.length === 0) return null;
    return h("ul", {
      className: "examples"
    }, h("div", {
      className: "list-section-header"
    }, section.title), items);
  }).filter(Boolean);
  var name = props.matches.name || '';
  var view = h(View, {
    name: name
  });
  return h("main", {
    className: "split-view"
  }, h("div", {
    className: "list-view"
  }, h("div", {
    className: "list-view-scroll"
  }, sections)), view);
};

},{"../data":198,"classnames":33,"preact":166,"preact-router":164,"preact-router/match":165}],198:[function(require,module,exports){
"use strict";

var getSectionData = require('./getSectionData');

var examplesData = require('./examples-data.json');

module.exports.examples = getSectionData(examplesData);

},{"./examples-data.json":196,"./getSectionData":197}],197:[function(require,module,exports){
"use strict";

module.exports = function (data) {
  var list = data.map(function (s) {
    return s.items;
  }).reduce(function (a, b) {
    return a.concat(b);
  }, []);
  var map = list.reduce(function (dict, item) {
    if (item.name in dict) throw new Error("Multiple items with the same name: ".concat(item.name));
    dict[item.name] = item;
    return dict;
  }, {});
  return {
    data: data,
    map: map,
    list: list
  };
};

},{}],196:[function(require,module,exports){
module.exports=[
  {
    "title": "Prints",
    "name": "prints",
    "items": [
      {
        "name": "canvas-10-print",
        "title": "10 PRINT"
      },
      {
        "name": "canvas-dot-flower",
        "title": "Dot Flower Business Card"
      },
      {
        "name": "canvas-generative-silhouette",
        "title": "Generative Silhouette"
      },
      {
        "name": "canvas-generative-arcs",
        "title": "Generative Arcs"
      },
      {
        "name": "canvas-abstract-risograph-print",
        "title": "Abstract Risograph Print"
      }
    ]
  },
  {
    "title": "Animated",
    "name": "animated",
    "items": [
      {
        "name": "animated-grid",
        "title": "2D Grid Animation"
      },
      {
        "name": "animated-scribble-curves",
        "title": "Scribble Curves"
      },
      {
        "name": "animated-regl-dither-blob",
        "title": "Dither Blob (WebGL/Regl)"
      },
      {
        "name": "animated-regl-fullscreen-shader",
        "title": "Fullscreen Shader (WebGL/Regl)"
      },
      {
        "name": "animated-simple-2d",
        "title": "Simple 2D Animation"
      },
      {
        "name": "animated-p5",
        "title": "Basic p5.js Integration"
      },
      {
        "name": "animated-three-basic-cube",
        "title": "Basic Three.js Integration"
      }
    ]
  },
  {
    "title": "Media",
    "name": "media",
    "items": [
      {
        "name": "canvas-image-processing",
        "title": "Image Processing"
      }
    ]
  },
  {
    "title": "Tests",
    "name": "tests",
    "items": [
      {
        "name": "canvas-pixel-processing",
        "title": "Per-Pixel Processing"
      }
    ]
  }
]

},{}],193:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/** @jsx h */
var _require = require('preact'),
    h = _require.h,
    Component = _require.Component; // Grab our sketch & settings


var sketch = require('./background-sketch'); // The actual canvas-sketch library


var canvasSketch = require('canvas-sketch'); // Utility for preact className


var classnames = require('classnames');

module.exports =
/*#__PURE__*/
function (_Component) {
  _inherits(Canvas, _Component);

  function Canvas() {
    _classCallCheck(this, Canvas);

    return _possibleConstructorReturn(this, _getPrototypeOf(Canvas).apply(this, arguments));
  }

  _createClass(Canvas, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      // Since we render() the canvas, it will be the 'base' element
      var canvas = this.base; // Setup a new canvas-sketch

      this.sketch = canvasSketch(sketch, Object.assign({}, sketch.settings, {
        canvas: canvas
      }));

      this._handleActive(this.props);
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(newProps) {
      this._handleActive(newProps);
    }
  }, {
    key: "_handleActive",
    value: function _handleActive(newProps) {
      this.sketch.then(function (sketch) {
        if (newProps.active && !sketch.playing) sketch.play();else sketch.stop();
      });
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(newProps) {
      return newProps.active !== this.props.active;
    }
  }, {
    key: "render",
    value: function render() {
      var className = classnames('background-canvas', {
        active: this.props.active
      });
      return h("canvas", {
        className: className
      });
    }
  }]);

  return Canvas;
}(Component);

},{"./background-sketch":195,"canvas-sketch":1,"classnames":33,"preact":166}],195:[function(require,module,exports){
"use strict";

var _require = require('../../../examples/util/math'),
    clamp01 = _require.clamp01,
    linspace = _require.linspace;

var Painter = require('../../../examples/util/canvas-painter');

var Random = require('../../../examples/util/random');

var tween = require('../../../examples/util/tween');

var _require2 = require('gl-matrix'),
    vec2 = _require2.vec2;

var settings = {
  animate: true,
  hotkeys: false
};

var sketch = function sketch(app) {
  var friction = 0.98;
  var particleCount = 300;
  var maxConnections = 5;
  var currentSpawnInterval = 0;
  var currentSpawnTime = 0; // Simple utility for 2D line/circle drawing

  var painter = Painter(app.context); // Create a list of 'particle' objects

  var particles = Array.from(new Array(particleCount)).map(function () {
    return {// We'll fill in the properties dynamically in spawn()
    };
  });

  var nextParticle = function nextParticle() {
    return particles.find(function (p) {
      return !p.active;
    });
  };

  var spawn = function spawn() {
    var particle = nextParticle();
    if (!particle) return; // none left in pool
    // Mark particle as active, no longer in pool

    particle.active = true; // Reset time

    particle.time = 0; // Choose a new position, we are in 0..1 space here

    var center = [0.5, 0.5];
    var scale = 0.4;
    var offset = Random.gaussian(0, 0.05);
    particle.position = vec2.add([], Random.onSquare(scale + offset), center); // Set some new random properties

    particle.duration = Random.range(3, 5);
    particle.radius = Random.range(1, 2);
    particle.connectionRadius = Random.range(0.1, 0.2);
    particle.speed = 1 / 1000;
    particle.animationDuration = 1; // Use a random point on unit circle to get a random velocity vector

    particle.velocity = Random.onCircle(1, particle.velocity);
    return particle;
  };

  var spawnMultiple = function spawnMultiple() {
    var count = Random.rangeFloor(1, 6);

    for (var i = 0; i < count; i++) {
      spawn();
    }
  };

  var tick = function tick(_ref) {
    var deltaTime = _ref.deltaTime,
        width = _ref.width,
        height = _ref.height;
    currentSpawnTime += deltaTime;

    if (currentSpawnTime > currentSpawnInterval) {
      currentSpawnTime = 0;
      currentSpawnInterval = Random.range(0.25, 0.35);
      spawnMultiple();
    }

    particles.forEach(function (particle) {
      if (!particle.active) return; // ignore dead/unused particles

      particle.time += deltaTime;

      if (particle.time > particle.duration) {
        particle.active = false;
        return;
      } // Move along velocity


      vec2.scaleAndAdd(particle.position, particle.position, particle.velocity, particle.speed);
      vec2.scale(particle.velocity, particle.velocity, friction);
    });
  };

  var render = function render(_ref2) {
    var context = _ref2.context,
        deltaTime = _ref2.deltaTime,
        width = _ref2.width,
        height = _ref2.height;
    painter.clear({
      fill: 'white',
      width: width,
      height: height
    });
    context.save(); // Update & draw each particle

    particles.forEach(function (particle) {
      // Skip inactive particles
      if (!particle.active) return;
      var size = particle.radius * tween({
        time: particle.time,
        ease: 'quadOut',
        edge: particle.animationDuration,
        duration: particle.duration
      }); // Paint circle

      painter.circle({
        alpha: 0.2,
        position: [particle.position[0] * width, particle.position[1] * height],
        radius: size
      }); // Paint connections

      var connectionRadius = particle.connectionRadius;

      for (var i = 0, c = 0; i < particles.length && c < maxConnections; i++) {
        var other = particles[i];
        if (other === particle || !other.active) continue; // skip self

        var dist = vec2.distance(other.position, particle.position);

        if (dist <= connectionRadius) {
          var distStr = Math.sin(Math.PI * clamp01(dist / connectionRadius)); // Need to map from 0..1 to 0..screenSize

          var positions = [particle.position, other.position].map(function (p) {
            return [p[0] * width, p[1] * height];
          });
          painter.polyline(positions, {
            alpha: 0.2 * distStr,
            stroke: 'black',
            lineWidth: 0.25 * distStr
          });
          c++;
        }
      }
    });
    context.restore();
  };

  return {
    render: render,
    tick: tick
  };
};

module.exports = sketch;
module.exports.settings = settings;

},{"../../../examples/util/canvas-painter":16,"../../../examples/util/math":18,"../../../examples/util/random":19,"../../../examples/util/tween":20,"gl-matrix":104}],165:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Link = exports.Match = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _preact = require('preact');

var _preactRouter = require('preact-router');

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Match = exports.Match = function (_Component) {
	_inherits(Match, _Component);

	function Match() {
		var _temp, _this, _ret;

		_classCallCheck(this, Match);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.update = function (url) {
			_this.nextUrl = url;
			_this.setState({});
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	Match.prototype.componentDidMount = function componentDidMount() {
		_preactRouter.subscribers.push(this.update);
	};

	Match.prototype.componentWillUnmount = function componentWillUnmount() {
		_preactRouter.subscribers.splice(_preactRouter.subscribers.indexOf(this.update) >>> 0, 1);
	};

	Match.prototype.render = function render(props) {
		var url = this.nextUrl || (0, _preactRouter.getCurrentUrl)(),
		    path = url.replace(/\?.+$/, '');
		this.nextUrl = null;
		return props.children[0] && props.children[0]({
			url: url,
			path: path,
			matches: path === props.path
		});
	};

	return Match;
}(_preact.Component);

var Link = function Link(_ref) {
	var activeClassName = _ref.activeClassName,
	    path = _ref.path,
	    props = _objectWithoutProperties(_ref, ['activeClassName', 'path']);

	return (0, _preact.h)(
		Match,
		{ path: path || props.href },
		function (_ref2) {
			var matches = _ref2.matches;
			return (0, _preact.h)(_preactRouter.Link, _extends({}, props, { 'class': [props.class || props.className, matches && activeClassName].filter(Boolean).join(' ') }));
		}
	);
};

exports.Link = Link;
exports.default = Match;

Match.Link = Link;

},{"preact":166,"preact-router":164}],164:[function(require,module,exports){
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e(require("preact")):"function"==typeof define&&define.amd?define(["preact"],e):t.preactRouter=e(t.preact)}(this,function(t){function e(t,e){for(var n in e)t[n]=e[n];return t}function n(t,e,n){var r,o=/(?:\?([^#]*))?(#.*)?$/,u=t.match(o),a={};if(u&&u[1])for(var p=u[1].split("&"),c=0;c<p.length;c++){var f=p[c].split("=");a[decodeURIComponent(f[0])]=decodeURIComponent(f.slice(1).join("="))}t=i(t.replace(o,"")),e=i(e||"");for(var l=Math.max(t.length,e.length),s=0;s<l;s++)if(e[s]&&":"===e[s].charAt(0)){var h=e[s].replace(/(^\:|[+*?]+$)/g,""),d=(e[s].match(/[+*?]+$/)||C)[0]||"",g=~d.indexOf("+"),m=~d.indexOf("*"),y=t[s]||"";if(!y&&!m&&(d.indexOf("?")<0||g)){r=!1;break}if(a[h]=decodeURIComponent(y),g||m){a[h]=t.slice(s).map(decodeURIComponent).join("/");break}}else if(e[s]!==t[s]){r=!1;break}return(!0===n.default||!1!==r)&&a}function r(t,e){return t.rank<e.rank?1:t.rank>e.rank?-1:t.index-e.index}function o(t,e){return t.index=e,t.rank=p(t),t.attributes}function i(t){return t.replace(/(^\/+|\/+$)/g,"").split("/")}function u(t){return":"==t.charAt(0)?1+"*+?".indexOf(t.charAt(t.length-1))||4:5}function a(t){return i(t).map(u).join("")}function p(t){return t.attributes.default?0:a(t.attributes.path)}function c(t){return null!=t.__preactattr_||"undefined"!=typeof Symbol&&null!=t[Symbol.for("preactattr")]}function f(t,e){void 0===e&&(e="push"),R&&R[e]?R[e](t):"undefined"!=typeof history&&history[e+"State"]&&history[e+"State"](null,null,t)}function l(){var t;return t=R&&R.location?R.location:R&&R.getCurrentLocation?R.getCurrentLocation():"undefined"!=typeof location?location:x,""+(t.pathname||"")+(t.search||"")}function s(t,e){return void 0===e&&(e=!1),"string"!=typeof t&&t.url&&(e=t.replace,t=t.url),h(t)&&f(t,e?"replace":"push"),d(t)}function h(t){for(var e=U.length;e--;)if(U[e].canRoute(t))return!0;return!1}function d(t){for(var e=!1,n=0;n<U.length;n++)!0===U[n].routeTo(t)&&(e=!0);for(var r=k.length;r--;)k[r](t);return e}function g(t){if(t&&t.getAttribute){var e=t.getAttribute("href"),n=t.getAttribute("target");if(e&&e.match(/^\//g)&&(!n||n.match(/^_?self$/i)))return s(e)}}function m(t){if(0==t.button)return g(t.currentTarget||t.target||this),y(t)}function y(t){return t&&(t.stopImmediatePropagation&&t.stopImmediatePropagation(),t.stopPropagation&&t.stopPropagation(),t.preventDefault()),!1}function v(t){if(!(t.ctrlKey||t.metaKey||t.altKey||t.shiftKey||0!==t.button)){var e=t.target;do{if("A"===(e.nodeName+"").toUpperCase()&&e.getAttribute("href")&&c(e)){if(e.hasAttribute("native"))return;if(g(e))return y(t)}}while(e=e.parentNode)}}function b(){_||("function"==typeof addEventListener&&(R||addEventListener("popstate",function(){d(l())}),addEventListener("click",v)),_=!0)}var C={},R=null,U=[],k=[],x={},_=!1,A=function(i){function u(t){i.call(this,t),t.history&&(R=t.history),this.state={url:t.url||l()},b()}return i&&(u.__proto__=i),u.prototype=Object.create(i&&i.prototype),u.prototype.constructor=u,u.prototype.shouldComponentUpdate=function(t){return!0!==t.static||(t.url!==this.props.url||t.onChange!==this.props.onChange)},u.prototype.canRoute=function(t){return this.getMatchingChildren(this.props.children,t,!1).length>0},u.prototype.routeTo=function(t){return this._didRoute=!1,this.setState({url:t}),this.updating?this.canRoute(t):(this.forceUpdate(),this._didRoute)},u.prototype.componentWillMount=function(){U.push(this),this.updating=!0},u.prototype.componentDidMount=function(){var t=this;R&&(this.unlisten=R.listen(function(e){t.routeTo(""+(e.pathname||"")+(e.search||""))})),this.updating=!1},u.prototype.componentWillUnmount=function(){"function"==typeof this.unlisten&&this.unlisten(),U.splice(U.indexOf(this),1)},u.prototype.componentWillUpdate=function(){this.updating=!0},u.prototype.componentDidUpdate=function(){this.updating=!1},u.prototype.getMatchingChildren=function(i,u,a){return i.filter(o).sort(r).map(function(r){var o=n(u,r.attributes.path,r.attributes);if(o){if(!1!==a){var i={url:u,matches:o};return e(i,o),delete i.ref,delete i.key,t.cloneElement(r,i)}return r}}).filter(Boolean)},u.prototype.render=function(t,e){var n=t.children,r=t.onChange,o=e.url,i=this.getMatchingChildren(n,o,!0),u=i[0]||null;this._didRoute=!!u;var a=this.previousUrl;return o!==a&&(this.previousUrl=o,"function"==typeof r&&r({router:this,url:o,previous:a,active:i,current:u})),u},u}(t.Component),I=function(n){return t.h("a",e({onClick:m},n))},L=function(e){return t.h(e.component,e)};return A.subscribers=k,A.getCurrentUrl=l,A.route=s,A.Router=A,A.Route=L,A.Link=I,A});


},{"preact":166}],166:[function(require,module,exports){
!function() {
    'use strict';
    function VNode() {}
    function h(nodeName, attributes) {
        var lastSimple, child, simple, i, children = EMPTY_CHILDREN;
        for (i = arguments.length; i-- > 2; ) stack.push(arguments[i]);
        if (attributes && null != attributes.children) {
            if (!stack.length) stack.push(attributes.children);
            delete attributes.children;
        }
        while (stack.length) if ((child = stack.pop()) && void 0 !== child.pop) for (i = child.length; i--; ) stack.push(child[i]); else {
            if ('boolean' == typeof child) child = null;
            if (simple = 'function' != typeof nodeName) if (null == child) child = ''; else if ('number' == typeof child) child = String(child); else if ('string' != typeof child) simple = !1;
            if (simple && lastSimple) children[children.length - 1] += child; else if (children === EMPTY_CHILDREN) children = [ child ]; else children.push(child);
            lastSimple = simple;
        }
        var p = new VNode();
        p.nodeName = nodeName;
        p.children = children;
        p.attributes = null == attributes ? void 0 : attributes;
        p.key = null == attributes ? void 0 : attributes.key;
        if (void 0 !== options.vnode) options.vnode(p);
        return p;
    }
    function extend(obj, props) {
        for (var i in props) obj[i] = props[i];
        return obj;
    }
    function cloneElement(vnode, props) {
        return h(vnode.nodeName, extend(extend({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);
    }
    function enqueueRender(component) {
        if (!component.__d && (component.__d = !0) && 1 == items.push(component)) (options.debounceRendering || defer)(rerender);
    }
    function rerender() {
        var p, list = items;
        items = [];
        while (p = list.pop()) if (p.__d) renderComponent(p);
    }
    function isSameNodeType(node, vnode, hydrating) {
        if ('string' == typeof vnode || 'number' == typeof vnode) return void 0 !== node.splitText;
        if ('string' == typeof vnode.nodeName) return !node._componentConstructor && isNamedNode(node, vnode.nodeName); else return hydrating || node._componentConstructor === vnode.nodeName;
    }
    function isNamedNode(node, nodeName) {
        return node.__n === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();
    }
    function getNodeProps(vnode) {
        var props = extend({}, vnode.attributes);
        props.children = vnode.children;
        var defaultProps = vnode.nodeName.defaultProps;
        if (void 0 !== defaultProps) for (var i in defaultProps) if (void 0 === props[i]) props[i] = defaultProps[i];
        return props;
    }
    function createNode(nodeName, isSvg) {
        var node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);
        node.__n = nodeName;
        return node;
    }
    function removeNode(node) {
        var parentNode = node.parentNode;
        if (parentNode) parentNode.removeChild(node);
    }
    function setAccessor(node, name, old, value, isSvg) {
        if ('className' === name) name = 'class';
        if ('key' === name) ; else if ('ref' === name) {
            if (old) old(null);
            if (value) value(node);
        } else if ('class' === name && !isSvg) node.className = value || ''; else if ('style' === name) {
            if (!value || 'string' == typeof value || 'string' == typeof old) node.style.cssText = value || '';
            if (value && 'object' == typeof value) {
                if ('string' != typeof old) for (var i in old) if (!(i in value)) node.style[i] = '';
                for (var i in value) node.style[i] = 'number' == typeof value[i] && !1 === IS_NON_DIMENSIONAL.test(i) ? value[i] + 'px' : value[i];
            }
        } else if ('dangerouslySetInnerHTML' === name) {
            if (value) node.innerHTML = value.__html || '';
        } else if ('o' == name[0] && 'n' == name[1]) {
            var useCapture = name !== (name = name.replace(/Capture$/, ''));
            name = name.toLowerCase().substring(2);
            if (value) {
                if (!old) node.addEventListener(name, eventProxy, useCapture);
            } else node.removeEventListener(name, eventProxy, useCapture);
            (node.__l || (node.__l = {}))[name] = value;
        } else if ('list' !== name && 'type' !== name && !isSvg && name in node) {
            setProperty(node, name, null == value ? '' : value);
            if (null == value || !1 === value) node.removeAttribute(name);
        } else {
            var ns = isSvg && name !== (name = name.replace(/^xlink:?/, ''));
            if (null == value || !1 === value) if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase()); else node.removeAttribute(name); else if ('function' != typeof value) if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value); else node.setAttribute(name, value);
        }
    }
    function setProperty(node, name, value) {
        try {
            node[name] = value;
        } catch (e) {}
    }
    function eventProxy(e) {
        return this.__l[e.type](options.event && options.event(e) || e);
    }
    function flushMounts() {
        var c;
        while (c = mounts.pop()) {
            if (options.afterMount) options.afterMount(c);
            if (c.componentDidMount) c.componentDidMount();
        }
    }
    function diff(dom, vnode, context, mountAll, parent, componentRoot) {
        if (!diffLevel++) {
            isSvgMode = null != parent && void 0 !== parent.ownerSVGElement;
            hydrating = null != dom && !('__preactattr_' in dom);
        }
        var ret = idiff(dom, vnode, context, mountAll, componentRoot);
        if (parent && ret.parentNode !== parent) parent.appendChild(ret);
        if (!--diffLevel) {
            hydrating = !1;
            if (!componentRoot) flushMounts();
        }
        return ret;
    }
    function idiff(dom, vnode, context, mountAll, componentRoot) {
        var out = dom, prevSvgMode = isSvgMode;
        if (null == vnode || 'boolean' == typeof vnode) vnode = '';
        if ('string' == typeof vnode || 'number' == typeof vnode) {
            if (dom && void 0 !== dom.splitText && dom.parentNode && (!dom._component || componentRoot)) {
                if (dom.nodeValue != vnode) dom.nodeValue = vnode;
            } else {
                out = document.createTextNode(vnode);
                if (dom) {
                    if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
                    recollectNodeTree(dom, !0);
                }
            }
            out.__preactattr_ = !0;
            return out;
        }
        var vnodeName = vnode.nodeName;
        if ('function' == typeof vnodeName) return buildComponentFromVNode(dom, vnode, context, mountAll);
        isSvgMode = 'svg' === vnodeName ? !0 : 'foreignObject' === vnodeName ? !1 : isSvgMode;
        vnodeName = String(vnodeName);
        if (!dom || !isNamedNode(dom, vnodeName)) {
            out = createNode(vnodeName, isSvgMode);
            if (dom) {
                while (dom.firstChild) out.appendChild(dom.firstChild);
                if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
                recollectNodeTree(dom, !0);
            }
        }
        var fc = out.firstChild, props = out.__preactattr_, vchildren = vnode.children;
        if (null == props) {
            props = out.__preactattr_ = {};
            for (var a = out.attributes, i = a.length; i--; ) props[a[i].name] = a[i].value;
        }
        if (!hydrating && vchildren && 1 === vchildren.length && 'string' == typeof vchildren[0] && null != fc && void 0 !== fc.splitText && null == fc.nextSibling) {
            if (fc.nodeValue != vchildren[0]) fc.nodeValue = vchildren[0];
        } else if (vchildren && vchildren.length || null != fc) innerDiffNode(out, vchildren, context, mountAll, hydrating || null != props.dangerouslySetInnerHTML);
        diffAttributes(out, vnode.attributes, props);
        isSvgMode = prevSvgMode;
        return out;
    }
    function innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {
        var j, c, f, vchild, child, originalChildren = dom.childNodes, children = [], keyed = {}, keyedLen = 0, min = 0, len = originalChildren.length, childrenLen = 0, vlen = vchildren ? vchildren.length : 0;
        if (0 !== len) for (var i = 0; i < len; i++) {
            var _child = originalChildren[i], props = _child.__preactattr_, key = vlen && props ? _child._component ? _child._component.__k : props.key : null;
            if (null != key) {
                keyedLen++;
                keyed[key] = _child;
            } else if (props || (void 0 !== _child.splitText ? isHydrating ? _child.nodeValue.trim() : !0 : isHydrating)) children[childrenLen++] = _child;
        }
        if (0 !== vlen) for (var i = 0; i < vlen; i++) {
            vchild = vchildren[i];
            child = null;
            var key = vchild.key;
            if (null != key) {
                if (keyedLen && void 0 !== keyed[key]) {
                    child = keyed[key];
                    keyed[key] = void 0;
                    keyedLen--;
                }
            } else if (!child && min < childrenLen) for (j = min; j < childrenLen; j++) if (void 0 !== children[j] && isSameNodeType(c = children[j], vchild, isHydrating)) {
                child = c;
                children[j] = void 0;
                if (j === childrenLen - 1) childrenLen--;
                if (j === min) min++;
                break;
            }
            child = idiff(child, vchild, context, mountAll);
            f = originalChildren[i];
            if (child && child !== dom && child !== f) if (null == f) dom.appendChild(child); else if (child === f.nextSibling) removeNode(f); else dom.insertBefore(child, f);
        }
        if (keyedLen) for (var i in keyed) if (void 0 !== keyed[i]) recollectNodeTree(keyed[i], !1);
        while (min <= childrenLen) if (void 0 !== (child = children[childrenLen--])) recollectNodeTree(child, !1);
    }
    function recollectNodeTree(node, unmountOnly) {
        var component = node._component;
        if (component) unmountComponent(component); else {
            if (null != node.__preactattr_ && node.__preactattr_.ref) node.__preactattr_.ref(null);
            if (!1 === unmountOnly || null == node.__preactattr_) removeNode(node);
            removeChildren(node);
        }
    }
    function removeChildren(node) {
        node = node.lastChild;
        while (node) {
            var next = node.previousSibling;
            recollectNodeTree(node, !0);
            node = next;
        }
    }
    function diffAttributes(dom, attrs, old) {
        var name;
        for (name in old) if ((!attrs || null == attrs[name]) && null != old[name]) setAccessor(dom, name, old[name], old[name] = void 0, isSvgMode);
        for (name in attrs) if (!('children' === name || 'innerHTML' === name || name in old && attrs[name] === ('value' === name || 'checked' === name ? dom[name] : old[name]))) setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);
    }
    function collectComponent(component) {
        var name = component.constructor.name;
        (components[name] || (components[name] = [])).push(component);
    }
    function createComponent(Ctor, props, context) {
        var inst, list = components[Ctor.name];
        if (Ctor.prototype && Ctor.prototype.render) {
            inst = new Ctor(props, context);
            Component.call(inst, props, context);
        } else {
            inst = new Component(props, context);
            inst.constructor = Ctor;
            inst.render = doRender;
        }
        if (list) for (var i = list.length; i--; ) if (list[i].constructor === Ctor) {
            inst.__b = list[i].__b;
            list.splice(i, 1);
            break;
        }
        return inst;
    }
    function doRender(props, state, context) {
        return this.constructor(props, context);
    }
    function setComponentProps(component, props, opts, context, mountAll) {
        if (!component.__x) {
            component.__x = !0;
            if (component.__r = props.ref) delete props.ref;
            if (component.__k = props.key) delete props.key;
            if (!component.base || mountAll) {
                if (component.componentWillMount) component.componentWillMount();
            } else if (component.componentWillReceiveProps) component.componentWillReceiveProps(props, context);
            if (context && context !== component.context) {
                if (!component.__c) component.__c = component.context;
                component.context = context;
            }
            if (!component.__p) component.__p = component.props;
            component.props = props;
            component.__x = !1;
            if (0 !== opts) if (1 === opts || !1 !== options.syncComponentUpdates || !component.base) renderComponent(component, 1, mountAll); else enqueueRender(component);
            if (component.__r) component.__r(component);
        }
    }
    function renderComponent(component, opts, mountAll, isChild) {
        if (!component.__x) {
            var rendered, inst, cbase, props = component.props, state = component.state, context = component.context, previousProps = component.__p || props, previousState = component.__s || state, previousContext = component.__c || context, isUpdate = component.base, nextBase = component.__b, initialBase = isUpdate || nextBase, initialChildComponent = component._component, skip = !1;
            if (isUpdate) {
                component.props = previousProps;
                component.state = previousState;
                component.context = previousContext;
                if (2 !== opts && component.shouldComponentUpdate && !1 === component.shouldComponentUpdate(props, state, context)) skip = !0; else if (component.componentWillUpdate) component.componentWillUpdate(props, state, context);
                component.props = props;
                component.state = state;
                component.context = context;
            }
            component.__p = component.__s = component.__c = component.__b = null;
            component.__d = !1;
            if (!skip) {
                rendered = component.render(props, state, context);
                if (component.getChildContext) context = extend(extend({}, context), component.getChildContext());
                var toUnmount, base, childComponent = rendered && rendered.nodeName;
                if ('function' == typeof childComponent) {
                    var childProps = getNodeProps(rendered);
                    inst = initialChildComponent;
                    if (inst && inst.constructor === childComponent && childProps.key == inst.__k) setComponentProps(inst, childProps, 1, context, !1); else {
                        toUnmount = inst;
                        component._component = inst = createComponent(childComponent, childProps, context);
                        inst.__b = inst.__b || nextBase;
                        inst.__u = component;
                        setComponentProps(inst, childProps, 0, context, !1);
                        renderComponent(inst, 1, mountAll, !0);
                    }
                    base = inst.base;
                } else {
                    cbase = initialBase;
                    toUnmount = initialChildComponent;
                    if (toUnmount) cbase = component._component = null;
                    if (initialBase || 1 === opts) {
                        if (cbase) cbase._component = null;
                        base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, !0);
                    }
                }
                if (initialBase && base !== initialBase && inst !== initialChildComponent) {
                    var baseParent = initialBase.parentNode;
                    if (baseParent && base !== baseParent) {
                        baseParent.replaceChild(base, initialBase);
                        if (!toUnmount) {
                            initialBase._component = null;
                            recollectNodeTree(initialBase, !1);
                        }
                    }
                }
                if (toUnmount) unmountComponent(toUnmount);
                component.base = base;
                if (base && !isChild) {
                    var componentRef = component, t = component;
                    while (t = t.__u) (componentRef = t).base = base;
                    base._component = componentRef;
                    base._componentConstructor = componentRef.constructor;
                }
            }
            if (!isUpdate || mountAll) mounts.unshift(component); else if (!skip) {
                if (component.componentDidUpdate) component.componentDidUpdate(previousProps, previousState, previousContext);
                if (options.afterUpdate) options.afterUpdate(component);
            }
            if (null != component.__h) while (component.__h.length) component.__h.pop().call(component);
            if (!diffLevel && !isChild) flushMounts();
        }
    }
    function buildComponentFromVNode(dom, vnode, context, mountAll) {
        var c = dom && dom._component, originalComponent = c, oldDom = dom, isDirectOwner = c && dom._componentConstructor === vnode.nodeName, isOwner = isDirectOwner, props = getNodeProps(vnode);
        while (c && !isOwner && (c = c.__u)) isOwner = c.constructor === vnode.nodeName;
        if (c && isOwner && (!mountAll || c._component)) {
            setComponentProps(c, props, 3, context, mountAll);
            dom = c.base;
        } else {
            if (originalComponent && !isDirectOwner) {
                unmountComponent(originalComponent);
                dom = oldDom = null;
            }
            c = createComponent(vnode.nodeName, props, context);
            if (dom && !c.__b) {
                c.__b = dom;
                oldDom = null;
            }
            setComponentProps(c, props, 1, context, mountAll);
            dom = c.base;
            if (oldDom && dom !== oldDom) {
                oldDom._component = null;
                recollectNodeTree(oldDom, !1);
            }
        }
        return dom;
    }
    function unmountComponent(component) {
        if (options.beforeUnmount) options.beforeUnmount(component);
        var base = component.base;
        component.__x = !0;
        if (component.componentWillUnmount) component.componentWillUnmount();
        component.base = null;
        var inner = component._component;
        if (inner) unmountComponent(inner); else if (base) {
            if (base.__preactattr_ && base.__preactattr_.ref) base.__preactattr_.ref(null);
            component.__b = base;
            removeNode(base);
            collectComponent(component);
            removeChildren(base);
        }
        if (component.__r) component.__r(null);
    }
    function Component(props, context) {
        this.__d = !0;
        this.context = context;
        this.props = props;
        this.state = this.state || {};
    }
    function render(vnode, parent, merge) {
        return diff(merge, vnode, {}, !1, parent, !1);
    }
    var options = {};
    var stack = [];
    var EMPTY_CHILDREN = [];
    var defer = 'function' == typeof Promise ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;
    var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
    var items = [];
    var mounts = [];
    var diffLevel = 0;
    var isSvgMode = !1;
    var hydrating = !1;
    var components = {};
    extend(Component.prototype, {
        setState: function(state, callback) {
            var s = this.state;
            if (!this.__s) this.__s = extend({}, s);
            extend(s, 'function' == typeof state ? state(s, this.props) : state);
            if (callback) (this.__h = this.__h || []).push(callback);
            enqueueRender(this);
        },
        forceUpdate: function(callback) {
            if (callback) (this.__h = this.__h || []).push(callback);
            renderComponent(this, 2);
        },
        render: function() {}
    });
    var preact = {
        h: h,
        createElement: h,
        cloneElement: cloneElement,
        Component: Component,
        render: render,
        rerender: rerender,
        options: options
    };
    if ('undefined' != typeof module) module.exports = preact; else self.preact = preact;
}();

},{}],33:[function(require,module,exports){
/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		// register as 'classnames', consistent with npm package name
		define('classnames', [], function () {
			return classNames;
		});
	} else {
		window.classNames = classNames;
	}
}());

},{}]},{},[199])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9mYWN0b3ItYnVuZGxlL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJ3ZWJzaXRlL3NyYy9pbmRleC5qcyIsIndlYnNpdGUvc3JjL2NvbXBvbmVudHMvRXhhbXBsZXMuanMiLCJ3ZWJzaXRlL3NyYy9kYXRhL2luZGV4LmpzIiwid2Vic2l0ZS9zcmMvZGF0YS9nZXRTZWN0aW9uRGF0YS5qcyIsIndlYnNpdGUvc3JjL2RhdGEvZXhhbXBsZXMtZGF0YS5qc29uIiwid2Vic2l0ZS9zcmMvY29tcG9uZW50cy9DYW52YXMuanMiLCJ3ZWJzaXRlL3NyYy9jb21wb25lbnRzL2JhY2tncm91bmQtc2tldGNoLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC1yb3V0ZXIvbWF0Y2guanMiLCJub2RlX21vZHVsZXMvcHJlYWN0LXJvdXRlci9kaXN0L3ByZWFjdC1yb3V0ZXIuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2Rpc3QvcHJlYWN0LmpzIiwibm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUNBLElBQU0sU0FBUyxRQUFRLGVBQVIsQ0FBZjs7ZUFFc0IsUUFBUSxRQUFSLEM7SUFBZCxDLFlBQUEsQztJQUFHLE0sWUFBQSxNOztnQkFDTSxRQUFRLHFCQUFSLEM7SUFBVCxJLGFBQUEsSTs7QUFDUixJQUFNLFNBQVMsUUFBUSxxQkFBUixDQUFmOztBQUNBLElBQU0sV0FBVyxRQUFRLHVCQUFSLENBQWpCOztBQUVBLElBQU0sWUFBWSwyQ0FBbEI7QUFDQSxJQUFNLGdCQUFnQixzRUFBdEI7O0FBRUEsSUFBTSxTQUFTLFNBQVQsTUFBUyxHQUFNO0FBQ25CLFNBQU87QUFBSyxlQUFVO0FBQWYsS0FDTCxrQkFDRSxFQUFDLElBQUQ7QUFBTSxVQUFLLEdBQVg7QUFBZSxlQUFVO0FBQXpCLHFCQURGLEVBRUUsZUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qKiBAanN4IGggKi9cbmNvbnN0IFJvdXRlciA9IHJlcXVpcmUoJ3ByZWFjdC1yb3V0ZXInKTtcblxuY29uc3QgeyBoLCByZW5kZXIgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpO1xuY29uc3QgeyBMaW5rIH0gPSByZXF1aXJlKCdwcmVhY3Qtcm91dGVyL21hdGNoJyk7XG5jb25zdCBDYW52YXMgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvQ2FudmFzJyk7XG5jb25zdCBFeGFtcGxlcyA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9FeGFtcGxlcycpO1xuXG5jb25zdCBnaXRIdWJVcmwgPSAnaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL2NhbnZhcy1za2V0Y2gnO1xuY29uc3QgZ2l0SHViVXJsRG9jcyA9ICdodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvY2FudmFzLXNrZXRjaC9ibG9iL21hc3Rlci9kb2NzL1JFQURNRS5tZCc7XG5cbmNvbnN0IE5hdmJhciA9ICgpID0+IHtcbiAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPSd0b3AtbmF2Jz5cbiAgICA8aGVhZGVyPlxuICAgICAgPExpbmsgaHJlZj0nLycgY2xhc3NOYW1lPSd0aXRsZSc+Y2FudmFzLXNrZXRjaDwvTGluaz5cbiAgICAgIDxuYXY+XG4gICAgICAgIDxMaW5rIGFjdGl2ZUNsYXNzTmFtZT0nYWN0aXZlJyBocmVmPScvZXhhbXBsZXMnPmV4YW1wbGVzPC9MaW5rPlxuICAgICAgICA8YSB0YXJnZXQ9J19ibGFuaycgaHJlZj17Z2l0SHViVXJsRG9jc30gY2xhc3NOYW1lPSdleHRlcm5hbCc+ZG9jczwvYT5cbiAgICAgICAgPGEgdGFyZ2V0PSdfYmxhbmsnIGhyZWY9e2dpdEh1YlVybH0gY2xhc3NOYW1lPSdleHRlcm5hbCc+Y29kZTwvYT5cbiAgICAgIDwvbmF2PlxuICAgIDwvaGVhZGVyPlxuICA8L2Rpdj47XG59O1xuXG5jb25zdCBGb290ZXIgPSAoKSA9PiB7XG4gIHJldHVybiA8Zm9vdGVyPlxuICAgIDxkaXYgY2xhc3NOYW1lPSdyb3RhdGVkLWJyaWVmJz5hIHRvb2xraXQgZm9yIGdlbmVyYXRpdmUgYXJ0PC9kaXY+XG4gICAgPGhyIGNsYXNzTmFtZT0ncmlnaHQnIC8+XG4gIDwvZm9vdGVyPjtcbn07XG5cbmNvbnN0IEhvbWUgPSAoKSA9PiB7XG4gIHJldHVybiA8bWFpbiBjbGFzc05hbWU9J2xhbmRpbmcnPlxuICAgIDxwPjxzdHJvbmc+Y2FudmFzLXNrZXRjaDwvc3Ryb25nPiBpcyBhIGxvb3NlIGNvbGxlY3Rpb24gb2YgdG9vbHMsIG1vZHVsZXMsIGFuZCByZXNvdXJjZXMgZm9yIGNyZWF0aW5nIGdlbmVyYXRpdmUgYXJ0IGluIEphdmFTY3JpcHQgYW5kIHRoZSBicm93c2VyLjwvcD5cbiAgICA8cD5JdCBjYW4gYmUgdXNlZCB0byByZW5kZXIgaGlnaC1xdWFsaXR5IFBORyBpbWFnZXMgZm9yIEdpY2zDqWUgcHJpbnRzLCBjcmVhdGUgcmVhbC10aW1lIHdlYiBncmFwaGljcyAoc3VjaCBhcyB0aGlzIHBhZ2UncyBiYWNrZ3JvdW5kKSwgZXhwb3J0IGltYWdlIHNlcXVlbmNlcyBmb3IgR0lGIGFuZCBNUDQgbG9vcHMsIGdlbmVyYXRlIFNWRyBmaWxlcyBmb3IgcGVuIHBsb3R0ZXJzIChsaWtlIEF4aURyYXcpLCBhdXRvbWF0aWNhbGx5IGdpdCBoYXNoIHlvdXIgYXJ0d29ya3MgZm9yIGxvbmctdGVybSBhcmNoaXZpbmcsIGFuZCBtb3JlLjwvcD5cbiAgICA8cD5UbyBnZXQgc3RhcnRlZCwgY2hlY2sgb3V0IHRoZSA8YSB0YXJnZXQ9J19ibGFuaycgaHJlZj17Z2l0SHViVXJsRG9jc30+ZG9jdW1lbnRhdGlvbjwvYT4sXG4gICAgb3IgYnJvd3NlIHRocm91Z2ggPExpbmsgaHJlZj0nL2V4YW1wbGVzJz5zb21lIGV4YW1wbGVzPC9MaW5rPixcbiAgICBvciB2aWV3IHRoZSA8YSB0YXJnZXQ9J19ibGFuaycgaHJlZj17Z2l0SHViVXJsfT5zb3VyY2UgY29kZTwvYT4gb24gR2l0SHViLjwvcD5cbiAgPC9tYWluPjtcbn07XG5cbmNvbnN0IERvY3MgPSAoKSA9PiB7XG4gIHJldHVybiA8bWFpbj5Eb2NzLi4uPC9tYWluPjtcbn07XG5cbmNsYXNzIENvbnRlbnQgZXh0ZW5kcyBSb3V0ZXIge1xuICByZW5kZXIgKHByb3BzLCBzdGF0ZSkge1xuICAgIGNvbnN0IGlzSG9tZSA9IHN0YXRlLnVybCA9PT0gJy8nO1xuICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT0nY29udGVudC1sYXllcic+XG4gICAgICA8Q2FudmFzIGFjdGl2ZT17aXNIb21lfSAvPlxuICAgICAgPE5hdmJhciAvPlxuICAgICAgeyBzdXBlci5yZW5kZXIocHJvcHMsIHN0YXRlKSB9XG4gICAgICB7IGlzSG9tZSAmJiA8Rm9vdGVyIC8+IH1cbiAgICA8L2Rpdj47XG4gIH1cbn1cblxuY29uc3QgQXBwID0gKHByb3BzLCBjb250ZXh0KSA9PiB7XG4gIHJldHVybiA8ZGl2IGNsYXNzTmFtZT0nYXBwJz5cbiAgICA8Q29udGVudD5cbiAgICAgIDxIb21lIHBhdGg9Jy8nIC8+XG4gICAgICA8RXhhbXBsZXMgcGF0aD0nL2V4YW1wbGVzLzpuYW1lPycgLz5cbiAgICA8L0NvbnRlbnQ+XG4gIDwvZGl2Pjtcbn07XG5cbnJlbmRlcig8QXBwIC8+LCBkb2N1bWVudC5ib2R5KTtcbiIsIi8qKiBAanN4IGggKi9cbmNvbnN0IGNsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5jb25zdCB7IHJvdXRlIH0gPSByZXF1aXJlKCdwcmVhY3Qtcm91dGVyJyk7XG5jb25zdCB7IGgsIENvbXBvbmVudCB9ID0gcmVxdWlyZSgncHJlYWN0Jyk7XG5jb25zdCB7IExpbmsgfSA9IHJlcXVpcmUoJ3ByZWFjdC1yb3V0ZXIvbWF0Y2gnKTtcblxuY29uc3QgeyBleGFtcGxlcyB9ID0gcmVxdWlyZSgnLi4vZGF0YScpO1xuXG5jb25zdCBjYWNoZWRTb3VyY2UgPSB7fTtcblxuY29uc3QgZ2V0U291cmNlID0gKG5hbWUpID0+IHtcbiAgY29uc3QgdXJsID0gYC9leGFtcGxlcy8ke25hbWV9LmpzYDtcbiAgaWYgKHVybCBpbiBjYWNoZWRTb3VyY2UpIHJldHVybiBjYWNoZWRTb3VyY2VbdXJsXTtcbiAgY29uc3QgcCA9IHdpbmRvdy5mZXRjaCh1cmwpLnRoZW4ocmVzcCA9PiByZXNwLnRleHQoKSk7XG4gIGNhY2hlZFNvdXJjZVt1cmxdID0gcDtcbiAgcmV0dXJuIHA7XG59O1xuXG5jb25zdCBFeGFtcGxlSXRlbSA9IChwcm9wcykgPT4ge1xuICBjb25zdCBiYXNlVXJsID0gJy9leGFtcGxlcyc7XG4gIGNvbnN0IHVybCA9IGAke2Jhc2VVcmx9LyR7cHJvcHMubmFtZX1gO1xuICByZXR1cm4gPGxpPlxuICAgIDxMaW5rIGFjdGl2ZUNsYXNzTmFtZT0nYWN0aXZlJyBocmVmPXt1cmx9Pntwcm9wcy50aXRsZX08L0xpbms+XG4gIDwvbGk+O1xufTtcblxuY2xhc3MgVmlldyBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICBjb2RlOiAnJ1xuICAgIH07XG4gIH1cblxuICBsb2FkU2tldGNoIChwcm9wcykge1xuICAgIGNvbnN0IG5hbWUgPSBwcm9wcy5uYW1lO1xuICAgIC8vIElmIHdlIGhhdmUgYSBuYW1lLCBzdGFydCBsb2FkaW5nXG4gICAgY29uc3QgbG9hZGluZyA9IEJvb2xlYW4obmFtZSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGxvYWRpbmcsIGNvZGU6ICcnIH0pO1xuICAgIGdldFNvdXJjZShuYW1lKS50aGVuKGNvZGUgPT4ge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGxvYWRpbmc6IGZhbHNlLCBjb2RlIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAocHJvcHMsIHN0YXRlKSB7XG4gICAgdGhpcy5sb2FkU2tldGNoKHByb3BzKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICB0aGlzLmxvYWRTa2V0Y2godGhpcy5wcm9wcyk7XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUgKCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQgJiYgd2luZG93LmhsanMgJiYgdGhpcy5zdGF0ZS5jb2RlICYmIHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICB0aGlzLmVsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy5zdGF0ZS5jb2RlO1xuICAgICAgd2luZG93LmhsanMuaGlnaGxpZ2h0QmxvY2sodGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlciAocHJvcHMpIHtcbiAgICBjb25zdCBuYW1lID0gcHJvcHMubmFtZTtcblxuICAgIC8vIFVzZXIgc2VsZWN0ZWQgYW4gZXhhbXBsZVxuICAgIGlmIChuYW1lKSB7XG4gICAgICBpZiAobmFtZSBpbiBleGFtcGxlcy5tYXApIHtcbiAgICAgICAgLy8gU2tldGNoIGV4aXN0cyFcbiAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuc3RhdGUuY29kZTtcbiAgICAgICAgaWYgKGNvZGUpIHtcbiAgICAgICAgICBjb25zdCBza2V0Y2ggPSBleGFtcGxlcy5tYXBbbmFtZV07XG4gICAgICAgICAgY29uc3QgY2xhc3NlcyA9IGNsYXNzbmFtZXMoJ2NvZGUnLCB7IGxvYWRpbmc6ICFjb2RlIH0pO1xuICAgICAgICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT0nc2tldGNoLXZpZXcnPlxuICAgICAgICAgICAgPGlmcmFtZSBjbGFzc05hbWU9J3NrZXRjaCcgc3JjPXtgZXhhbXBsZXMvYnVpbGQvJHtza2V0Y2gubmFtZX0uaHRtbGB9IHdpZHRoPScxMDAlJyBoZWlnaHQ9JzEwMCUnIC8+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlc30+XG4gICAgICAgICAgICAgIDxwcmU+XG4gICAgICAgICAgICAgICAgPGNvZGUgY2xhc3NOYW1lPSdqcycgcmVmPXtjID0+IHsgdGhpcy5lbGVtZW50ID0gYzsgfX0gLz5cbiAgICAgICAgICAgICAgPC9wcmU+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPSdza2V0Y2gtdmlldyBuby1za2V0Y2gnPjxwPmxvYWRpbmc8L3A+PC9kaXY+O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTa2V0Y2ggZG9lc24ndCBleGlzdFxuICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmaW5kIGV4YW1wbGUgYnkgaWQgJHtuYW1lfWApO1xuICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9J3NrZXRjaC12aWV3IG5vLXNrZXRjaCc+PHA+Tm8gc2tldGNoIGZvdW5kIGJ5IHRoZSBuYW1lIDxzdHJvbmc+e25hbWV9PC9zdHJvbmc+LDwvcD48cD50cnkgY2hvb3NpbmcgYSBkaWZmZXJlbnQgb25lIGZyb20gdGhlIGxpc3Q8L3A+PC9kaXY+O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT0nc2tldGNoLXZpZXcgbm8tc2tldGNoJz5cbiAgICAgIDxwPkNob29zZSBhIHNrZXRjaCBmcm9tIHRoZSBsaXN0IHRvIGJlZ2luLjwvcD5cbiAgICAgIHsvKiBJdCdzIGEgYml0IGF3a3dhcmQgc2luY2UgdGhlIHVzZXIgaGFzIHRvIGNsaWNrIHRoZSBpZnJhbWUgdG8gZ2FpbiBmb2N1cyBmaXJzdC4uLiA6XFwgKi99XG4gICAgICB7LyogPHAgY2xhc3NOYW1lPSdob3RrZXktdGlwJz5XaGlsZSB2aWV3aW5nIGEgc2tldGNoLCBwdXNoIDxjb2RlIGNsYXNzTmFtZT0naG90a2V5Jz5DdHJsICsgUzwvY29kZT4gb3IgPGNvZGUgY2xhc3NOYW1lPSdob3RrZXknPkNtZCArIFM8L2NvZGU+IHRvIGRvd25sb2FkIHRoZSBhcnR3b3JrLjwvcD4gKi99XG4gICAgPC9kaXY+O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKHByb3BzLCBjb250ZXh0KSA9PiB7XG4gIGNvbnN0IHNlY3Rpb25zID0gZXhhbXBsZXMuZGF0YS5tYXAoc2VjdGlvbiA9PiB7XG4gICAgaWYgKCFzZWN0aW9uLm5hbWUpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBcIm5hbWVcIiBmaWVsZCBpbiBzZWN0aW9uIGZyb20gZXhhbXBsZXMtZGF0YS5qc29uJyk7XG4gICAgY29uc3QgaXRlbURhdGEgPSBzZWN0aW9uLml0ZW1zIHx8IFtdO1xuICAgIGNvbnN0IGl0ZW1zID0gaXRlbURhdGEuZmlsdGVyKGQgPT4gZC52aXNpYmxlICE9PSBmYWxzZSkubWFwKGRhdGEgPT4ge1xuICAgICAgcmV0dXJuIDxFeGFtcGxlSXRlbSB7Li4uZGF0YX0gbmFtZT17ZGF0YS5uYW1lfSAvPjtcbiAgICB9KTtcbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gPHVsIGNsYXNzTmFtZT0nZXhhbXBsZXMnPlxuICAgICAgPGRpdiBjbGFzc05hbWU9J2xpc3Qtc2VjdGlvbi1oZWFkZXInPntzZWN0aW9uLnRpdGxlfTwvZGl2PlxuICAgICAge2l0ZW1zfVxuICAgIDwvdWw+O1xuICB9KS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgbGV0IG5hbWUgPSBwcm9wcy5tYXRjaGVzLm5hbWUgfHwgJyc7XG4gIGNvbnN0IHZpZXcgPSA8VmlldyBuYW1lPXtuYW1lfSAvPjtcbiAgcmV0dXJuIDxtYWluIGNsYXNzTmFtZT0nc3BsaXQtdmlldyc+XG4gICAgPGRpdiBjbGFzc05hbWU9J2xpc3Qtdmlldyc+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT0nbGlzdC12aWV3LXNjcm9sbCc+e3NlY3Rpb25zfTwvZGl2PlxuICAgIDwvZGl2PlxuICAgIHt2aWV3fVxuICA8L21haW4+O1xufTtcbiIsImNvbnN0IGdldFNlY3Rpb25EYXRhID0gcmVxdWlyZSgnLi9nZXRTZWN0aW9uRGF0YScpO1xuY29uc3QgZXhhbXBsZXNEYXRhID0gcmVxdWlyZSgnLi9leGFtcGxlcy1kYXRhLmpzb24nKTtcbm1vZHVsZS5leHBvcnRzLmV4YW1wbGVzID0gZ2V0U2VjdGlvbkRhdGEoZXhhbXBsZXNEYXRhKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgY29uc3QgbGlzdCA9IGRhdGEubWFwKHMgPT4gcy5pdGVtcykucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pO1xuICBjb25zdCBtYXAgPSBsaXN0LnJlZHVjZSgoZGljdCwgaXRlbSkgPT4ge1xuICAgIGlmIChpdGVtLm5hbWUgaW4gZGljdCkgdGhyb3cgbmV3IEVycm9yKGBNdWx0aXBsZSBpdGVtcyB3aXRoIHRoZSBzYW1lIG5hbWU6ICR7aXRlbS5uYW1lfWApO1xuICAgIGRpY3RbaXRlbS5uYW1lXSA9IGl0ZW07XG4gICAgcmV0dXJuIGRpY3Q7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhLFxuICAgIG1hcCxcbiAgICBsaXN0XG4gIH07XG59O1xuIiwibW9kdWxlLmV4cG9ydHM9W1xuICB7XG4gICAgXCJ0aXRsZVwiOiBcIlByaW50c1wiLFxuICAgIFwibmFtZVwiOiBcInByaW50c1wiLFxuICAgIFwiaXRlbXNcIjogW1xuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJjYW52YXMtMTAtcHJpbnRcIixcbiAgICAgICAgXCJ0aXRsZVwiOiBcIjEwIFBSSU5UXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImNhbnZhcy1kb3QtZmxvd2VyXCIsXG4gICAgICAgIFwidGl0bGVcIjogXCJEb3QgRmxvd2VyIEJ1c2luZXNzIENhcmRcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiY2FudmFzLWdlbmVyYXRpdmUtc2lsaG91ZXR0ZVwiLFxuICAgICAgICBcInRpdGxlXCI6IFwiR2VuZXJhdGl2ZSBTaWxob3VldHRlXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImNhbnZhcy1nZW5lcmF0aXZlLWFyY3NcIixcbiAgICAgICAgXCJ0aXRsZVwiOiBcIkdlbmVyYXRpdmUgQXJjc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJjYW52YXMtYWJzdHJhY3Qtcmlzb2dyYXBoLXByaW50XCIsXG4gICAgICAgIFwidGl0bGVcIjogXCJBYnN0cmFjdCBSaXNvZ3JhcGggUHJpbnRcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGl0bGVcIjogXCJBbmltYXRlZFwiLFxuICAgIFwibmFtZVwiOiBcImFuaW1hdGVkXCIsXG4gICAgXCJpdGVtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFuaW1hdGVkLWdyaWRcIixcbiAgICAgICAgXCJ0aXRsZVwiOiBcIjJEIEdyaWQgQW5pbWF0aW9uXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFuaW1hdGVkLXNjcmliYmxlLWN1cnZlc1wiLFxuICAgICAgICBcInRpdGxlXCI6IFwiU2NyaWJibGUgQ3VydmVzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFuaW1hdGVkLXJlZ2wtZGl0aGVyLWJsb2JcIixcbiAgICAgICAgXCJ0aXRsZVwiOiBcIkRpdGhlciBCbG9iIChXZWJHTC9SZWdsKVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhbmltYXRlZC1yZWdsLWZ1bGxzY3JlZW4tc2hhZGVyXCIsXG4gICAgICAgIFwidGl0bGVcIjogXCJGdWxsc2NyZWVuIFNoYWRlciAoV2ViR0wvUmVnbClcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiYW5pbWF0ZWQtc2ltcGxlLTJkXCIsXG4gICAgICAgIFwidGl0bGVcIjogXCJTaW1wbGUgMkQgQW5pbWF0aW9uXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImFuaW1hdGVkLXA1XCIsXG4gICAgICAgIFwidGl0bGVcIjogXCJCYXNpYyBwNS5qcyBJbnRlZ3JhdGlvblwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJhbmltYXRlZC10aHJlZS1iYXNpYy1jdWJlXCIsXG4gICAgICAgIFwidGl0bGVcIjogXCJCYXNpYyBUaHJlZS5qcyBJbnRlZ3JhdGlvblwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJ0aXRsZVwiOiBcIk1lZGlhXCIsXG4gICAgXCJuYW1lXCI6IFwibWVkaWFcIixcbiAgICBcIml0ZW1zXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiY2FudmFzLWltYWdlLXByb2Nlc3NpbmdcIixcbiAgICAgICAgXCJ0aXRsZVwiOiBcIkltYWdlIFByb2Nlc3NpbmdcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwidGl0bGVcIjogXCJUZXN0c1wiLFxuICAgIFwibmFtZVwiOiBcInRlc3RzXCIsXG4gICAgXCJpdGVtc1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcImNhbnZhcy1waXhlbC1wcm9jZXNzaW5nXCIsXG4gICAgICAgIFwidGl0bGVcIjogXCJQZXItUGl4ZWwgUHJvY2Vzc2luZ1wiXG4gICAgICB9XG4gICAgXVxuICB9XG5dXG4iLCIvKiogQGpzeCBoICovXG5jb25zdCB7IGgsIENvbXBvbmVudCB9ID0gcmVxdWlyZSgncHJlYWN0Jyk7XG5cbi8vIEdyYWIgb3VyIHNrZXRjaCAmIHNldHRpbmdzXG5jb25zdCBza2V0Y2ggPSByZXF1aXJlKCcuL2JhY2tncm91bmQtc2tldGNoJyk7XG5cbi8vIFRoZSBhY3R1YWwgY2FudmFzLXNrZXRjaCBsaWJyYXJ5XG5jb25zdCBjYW52YXNTa2V0Y2ggPSByZXF1aXJlKCdjYW52YXMtc2tldGNoJyk7XG5cbi8vIFV0aWxpdHkgZm9yIHByZWFjdCBjbGFzc05hbWVcbmNvbnN0IGNsYXNzbmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQ2FudmFzIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgLy8gU2luY2Ugd2UgcmVuZGVyKCkgdGhlIGNhbnZhcywgaXQgd2lsbCBiZSB0aGUgJ2Jhc2UnIGVsZW1lbnRcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmJhc2U7XG5cbiAgICAvLyBTZXR1cCBhIG5ldyBjYW52YXMtc2tldGNoXG4gICAgdGhpcy5za2V0Y2ggPSBjYW52YXNTa2V0Y2goc2tldGNoLCBPYmplY3QuYXNzaWduKHt9LCBza2V0Y2guc2V0dGluZ3MsIHsgY2FudmFzIH0pKTtcbiAgICB0aGlzLl9oYW5kbGVBY3RpdmUodGhpcy5wcm9wcyk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIChuZXdQcm9wcykge1xuICAgIHRoaXMuX2hhbmRsZUFjdGl2ZShuZXdQcm9wcyk7XG4gIH1cblxuICBfaGFuZGxlQWN0aXZlIChuZXdQcm9wcykge1xuICAgIHRoaXMuc2tldGNoLnRoZW4oc2tldGNoID0+IHtcbiAgICAgIGlmIChuZXdQcm9wcy5hY3RpdmUgJiYgIXNrZXRjaC5wbGF5aW5nKSBza2V0Y2gucGxheSgpO1xuICAgICAgZWxzZSBza2V0Y2guc3RvcCgpO1xuICAgIH0pO1xuICB9XG5cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlIChuZXdQcm9wcykge1xuICAgIHJldHVybiBuZXdQcm9wcy5hY3RpdmUgIT09IHRoaXMucHJvcHMuYWN0aXZlO1xuICB9XG5cbiAgcmVuZGVyICgpIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBjbGFzc25hbWVzKCdiYWNrZ3JvdW5kLWNhbnZhcycsIHtcbiAgICAgIGFjdGl2ZTogdGhpcy5wcm9wcy5hY3RpdmVcbiAgICB9KTtcbiAgICByZXR1cm4gPGNhbnZhcyBjbGFzc05hbWU9e2NsYXNzTmFtZX0gLz47XG4gIH1cbn07XG4iLCJjb25zdCB7IGNsYW1wMDEsIGxpbnNwYWNlIH0gPSByZXF1aXJlKCcuLi8uLi8uLi9leGFtcGxlcy91dGlsL21hdGgnKTtcbmNvbnN0IFBhaW50ZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9leGFtcGxlcy91dGlsL2NhbnZhcy1wYWludGVyJyk7XG5jb25zdCBSYW5kb20gPSByZXF1aXJlKCcuLi8uLi8uLi9leGFtcGxlcy91dGlsL3JhbmRvbScpO1xuY29uc3QgdHdlZW4gPSByZXF1aXJlKCcuLi8uLi8uLi9leGFtcGxlcy91dGlsL3R3ZWVuJyk7XG5jb25zdCB7IHZlYzIgfSA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpO1xuXG5jb25zdCBzZXR0aW5ncyA9IHtcbiAgYW5pbWF0ZTogdHJ1ZSxcbiAgaG90a2V5czogZmFsc2Vcbn07XG5cbmNvbnN0IHNrZXRjaCA9IChhcHApID0+IHtcbiAgY29uc3QgZnJpY3Rpb24gPSAwLjk4O1xuICBjb25zdCBwYXJ0aWNsZUNvdW50ID0gMzAwO1xuICBsZXQgbWF4Q29ubmVjdGlvbnMgPSA1O1xuICBsZXQgY3VycmVudFNwYXduSW50ZXJ2YWwgPSAwO1xuICBsZXQgY3VycmVudFNwYXduVGltZSA9IDA7XG5cbiAgLy8gU2ltcGxlIHV0aWxpdHkgZm9yIDJEIGxpbmUvY2lyY2xlIGRyYXdpbmdcbiAgY29uc3QgcGFpbnRlciA9IFBhaW50ZXIoYXBwLmNvbnRleHQpO1xuXG4gIC8vIENyZWF0ZSBhIGxpc3Qgb2YgJ3BhcnRpY2xlJyBvYmplY3RzXG4gIGNvbnN0IHBhcnRpY2xlcyA9IEFycmF5LmZyb20obmV3IEFycmF5KHBhcnRpY2xlQ291bnQpKS5tYXAoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBXZSdsbCBmaWxsIGluIHRoZSBwcm9wZXJ0aWVzIGR5bmFtaWNhbGx5IGluIHNwYXduKClcbiAgICB9O1xuICB9KTtcblxuICBjb25zdCBuZXh0UGFydGljbGUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHBhcnRpY2xlcy5maW5kKHAgPT4gIXAuYWN0aXZlKTtcbiAgfTtcblxuICBjb25zdCBzcGF3biA9ICgpID0+IHtcbiAgICBjb25zdCBwYXJ0aWNsZSA9IG5leHRQYXJ0aWNsZSgpO1xuICAgIGlmICghcGFydGljbGUpIHJldHVybjsgLy8gbm9uZSBsZWZ0IGluIHBvb2xcblxuICAgIC8vIE1hcmsgcGFydGljbGUgYXMgYWN0aXZlLCBubyBsb25nZXIgaW4gcG9vbFxuICAgIHBhcnRpY2xlLmFjdGl2ZSA9IHRydWU7XG5cbiAgICAvLyBSZXNldCB0aW1lXG4gICAgcGFydGljbGUudGltZSA9IDA7XG5cbiAgICAvLyBDaG9vc2UgYSBuZXcgcG9zaXRpb24sIHdlIGFyZSBpbiAwLi4xIHNwYWNlIGhlcmVcbiAgICBjb25zdCBjZW50ZXIgPSBbIDAuNSwgMC41IF07XG4gICAgY29uc3Qgc2NhbGUgPSAwLjQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gUmFuZG9tLmdhdXNzaWFuKDAsIDAuMDUpO1xuICAgIHBhcnRpY2xlLnBvc2l0aW9uID0gdmVjMi5hZGQoW10sIFJhbmRvbS5vblNxdWFyZShzY2FsZSArIG9mZnNldCksIGNlbnRlcik7XG5cbiAgICAvLyBTZXQgc29tZSBuZXcgcmFuZG9tIHByb3BlcnRpZXNcbiAgICBwYXJ0aWNsZS5kdXJhdGlvbiA9IFJhbmRvbS5yYW5nZSgzLCA1KTtcbiAgICBwYXJ0aWNsZS5yYWRpdXMgPSBSYW5kb20ucmFuZ2UoMSwgMik7XG4gICAgcGFydGljbGUuY29ubmVjdGlvblJhZGl1cyA9IFJhbmRvbS5yYW5nZSgwLjEsIDAuMik7XG4gICAgcGFydGljbGUuc3BlZWQgPSAxIC8gMTAwMDtcbiAgICBwYXJ0aWNsZS5hbmltYXRpb25EdXJhdGlvbiA9IDE7XG5cbiAgICAvLyBVc2UgYSByYW5kb20gcG9pbnQgb24gdW5pdCBjaXJjbGUgdG8gZ2V0IGEgcmFuZG9tIHZlbG9jaXR5IHZlY3RvclxuICAgIHBhcnRpY2xlLnZlbG9jaXR5ID0gUmFuZG9tLm9uQ2lyY2xlKDEsIHBhcnRpY2xlLnZlbG9jaXR5KTtcblxuICAgIHJldHVybiBwYXJ0aWNsZTtcbiAgfTtcblxuICBjb25zdCBzcGF3bk11bHRpcGxlID0gKCkgPT4ge1xuICAgIGNvbnN0IGNvdW50ID0gUmFuZG9tLnJhbmdlRmxvb3IoMSwgNik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSBzcGF3bigpO1xuICB9O1xuXG4gIGNvbnN0IHRpY2sgPSAoeyBkZWx0YVRpbWUsIHdpZHRoLCBoZWlnaHQgfSkgPT4ge1xuICAgIGN1cnJlbnRTcGF3blRpbWUgKz0gZGVsdGFUaW1lO1xuICAgIGlmIChjdXJyZW50U3Bhd25UaW1lID4gY3VycmVudFNwYXduSW50ZXJ2YWwpIHtcbiAgICAgIGN1cnJlbnRTcGF3blRpbWUgPSAwO1xuICAgICAgY3VycmVudFNwYXduSW50ZXJ2YWwgPSBSYW5kb20ucmFuZ2UoMC4yNSwgMC4zNSk7XG4gICAgICBzcGF3bk11bHRpcGxlKCk7XG4gICAgfVxuXG4gICAgcGFydGljbGVzLmZvckVhY2gocGFydGljbGUgPT4ge1xuICAgICAgaWYgKCFwYXJ0aWNsZS5hY3RpdmUpIHJldHVybjsgLy8gaWdub3JlIGRlYWQvdW51c2VkIHBhcnRpY2xlc1xuXG4gICAgICBwYXJ0aWNsZS50aW1lICs9IGRlbHRhVGltZTtcbiAgICAgIGlmIChwYXJ0aWNsZS50aW1lID4gcGFydGljbGUuZHVyYXRpb24pIHtcbiAgICAgICAgcGFydGljbGUuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTW92ZSBhbG9uZyB2ZWxvY2l0eVxuICAgICAgdmVjMi5zY2FsZUFuZEFkZChwYXJ0aWNsZS5wb3NpdGlvbiwgcGFydGljbGUucG9zaXRpb24sIHBhcnRpY2xlLnZlbG9jaXR5LCBwYXJ0aWNsZS5zcGVlZCk7XG4gICAgICB2ZWMyLnNjYWxlKHBhcnRpY2xlLnZlbG9jaXR5LCBwYXJ0aWNsZS52ZWxvY2l0eSwgZnJpY3Rpb24pO1xuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IHJlbmRlciA9ICh7IGNvbnRleHQsIGRlbHRhVGltZSwgd2lkdGgsIGhlaWdodCB9KSA9PiB7XG4gICAgcGFpbnRlci5jbGVhcih7IGZpbGw6ICd3aGl0ZScsIHdpZHRoLCBoZWlnaHQgfSk7XG5cbiAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgIC8vIFVwZGF0ZSAmIGRyYXcgZWFjaCBwYXJ0aWNsZVxuICAgIHBhcnRpY2xlcy5mb3JFYWNoKHBhcnRpY2xlID0+IHtcbiAgICAgIC8vIFNraXAgaW5hY3RpdmUgcGFydGljbGVzXG4gICAgICBpZiAoIXBhcnRpY2xlLmFjdGl2ZSkgcmV0dXJuO1xuXG4gICAgICBjb25zdCBzaXplID0gcGFydGljbGUucmFkaXVzICogdHdlZW4oe1xuICAgICAgICB0aW1lOiBwYXJ0aWNsZS50aW1lLFxuICAgICAgICBlYXNlOiAncXVhZE91dCcsXG4gICAgICAgIGVkZ2U6IHBhcnRpY2xlLmFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICBkdXJhdGlvbjogcGFydGljbGUuZHVyYXRpb25cbiAgICAgIH0pO1xuXG4gICAgICAvLyBQYWludCBjaXJjbGVcbiAgICAgIHBhaW50ZXIuY2lyY2xlKHtcbiAgICAgICAgYWxwaGE6IDAuMixcbiAgICAgICAgcG9zaXRpb246IFsgcGFydGljbGUucG9zaXRpb25bMF0gKiB3aWR0aCwgcGFydGljbGUucG9zaXRpb25bMV0gKiBoZWlnaHQgXSxcbiAgICAgICAgcmFkaXVzOiBzaXplXG4gICAgICB9KTtcblxuICAgICAgLy8gUGFpbnQgY29ubmVjdGlvbnNcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb25SYWRpdXMgPSBwYXJ0aWNsZS5jb25uZWN0aW9uUmFkaXVzO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGMgPSAwOyBpIDwgcGFydGljbGVzLmxlbmd0aCAmJiBjIDwgbWF4Q29ubmVjdGlvbnM7IGkrKykge1xuICAgICAgICBjb25zdCBvdGhlciA9IHBhcnRpY2xlc1tpXTtcbiAgICAgICAgaWYgKG90aGVyID09PSBwYXJ0aWNsZSB8fCAhb3RoZXIuYWN0aXZlKSBjb250aW51ZTsgLy8gc2tpcCBzZWxmXG4gICAgICAgIGNvbnN0IGRpc3QgPSB2ZWMyLmRpc3RhbmNlKG90aGVyLnBvc2l0aW9uLCBwYXJ0aWNsZS5wb3NpdGlvbik7XG4gICAgICAgIGlmIChkaXN0IDw9IGNvbm5lY3Rpb25SYWRpdXMpIHtcbiAgICAgICAgICBjb25zdCBkaXN0U3RyID0gTWF0aC5zaW4oTWF0aC5QSSAqIGNsYW1wMDEoZGlzdCAvIGNvbm5lY3Rpb25SYWRpdXMpKTtcbiAgICAgICAgICAvLyBOZWVkIHRvIG1hcCBmcm9tIDAuLjEgdG8gMC4uc2NyZWVuU2l6ZVxuICAgICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IFsgcGFydGljbGUucG9zaXRpb24sIG90aGVyLnBvc2l0aW9uIF0ubWFwKHAgPT4gKFxuICAgICAgICAgICAgWyBwWzBdICogd2lkdGgsIHBbMV0gKiBoZWlnaHQgXVxuICAgICAgICAgICkpO1xuICAgICAgICAgIHBhaW50ZXIucG9seWxpbmUocG9zaXRpb25zLCB7XG4gICAgICAgICAgICBhbHBoYTogMC4yICogZGlzdFN0cixcbiAgICAgICAgICAgIHN0cm9rZTogJ2JsYWNrJyxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMC4yNSAqIGRpc3RTdHJcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGMrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICByZW5kZXIsXG4gICAgdGlja1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBza2V0Y2g7XG5tb2R1bGUuZXhwb3J0cy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5MaW5rID0gZXhwb3J0cy5NYXRjaCA9IHVuZGVmaW5lZDtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9wcmVhY3QgPSByZXF1aXJlKCdwcmVhY3QnKTtcblxudmFyIF9wcmVhY3RSb3V0ZXIgPSByZXF1aXJlKCdwcmVhY3Qtcm91dGVyJyk7XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgTWF0Y2ggPSBleHBvcnRzLk1hdGNoID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcblx0X2luaGVyaXRzKE1hdGNoLCBfQ29tcG9uZW50KTtcblxuXHRmdW5jdGlvbiBNYXRjaCgpIHtcblx0XHR2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hdGNoKTtcblxuXHRcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG5cdFx0XHRhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuXHRcdH1cblxuXHRcdHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsLmFwcGx5KF9Db21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy51cGRhdGUgPSBmdW5jdGlvbiAodXJsKSB7XG5cdFx0XHRfdGhpcy5uZXh0VXJsID0gdXJsO1xuXHRcdFx0X3RoaXMuc2V0U3RhdGUoe30pO1xuXHRcdH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuXHR9XG5cblx0TWF0Y2gucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0X3ByZWFjdFJvdXRlci5zdWJzY3JpYmVycy5wdXNoKHRoaXMudXBkYXRlKTtcblx0fTtcblxuXHRNYXRjaC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcblx0XHRfcHJlYWN0Um91dGVyLnN1YnNjcmliZXJzLnNwbGljZShfcHJlYWN0Um91dGVyLnN1YnNjcmliZXJzLmluZGV4T2YodGhpcy51cGRhdGUpID4+PiAwLCAxKTtcblx0fTtcblxuXHRNYXRjaC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHByb3BzKSB7XG5cdFx0dmFyIHVybCA9IHRoaXMubmV4dFVybCB8fCAoMCwgX3ByZWFjdFJvdXRlci5nZXRDdXJyZW50VXJsKSgpLFxuXHRcdCAgICBwYXRoID0gdXJsLnJlcGxhY2UoL1xcPy4rJC8sICcnKTtcblx0XHR0aGlzLm5leHRVcmwgPSBudWxsO1xuXHRcdHJldHVybiBwcm9wcy5jaGlsZHJlblswXSAmJiBwcm9wcy5jaGlsZHJlblswXSh7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHBhdGg6IHBhdGgsXG5cdFx0XHRtYXRjaGVzOiBwYXRoID09PSBwcm9wcy5wYXRoXG5cdFx0fSk7XG5cdH07XG5cblx0cmV0dXJuIE1hdGNoO1xufShfcHJlYWN0LkNvbXBvbmVudCk7XG5cbnZhciBMaW5rID0gZnVuY3Rpb24gTGluayhfcmVmKSB7XG5cdHZhciBhY3RpdmVDbGFzc05hbWUgPSBfcmVmLmFjdGl2ZUNsYXNzTmFtZSxcblx0ICAgIHBhdGggPSBfcmVmLnBhdGgsXG5cdCAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2FjdGl2ZUNsYXNzTmFtZScsICdwYXRoJ10pO1xuXG5cdHJldHVybiAoMCwgX3ByZWFjdC5oKShcblx0XHRNYXRjaCxcblx0XHR7IHBhdGg6IHBhdGggfHwgcHJvcHMuaHJlZiB9LFxuXHRcdGZ1bmN0aW9uIChfcmVmMikge1xuXHRcdFx0dmFyIG1hdGNoZXMgPSBfcmVmMi5tYXRjaGVzO1xuXHRcdFx0cmV0dXJuICgwLCBfcHJlYWN0LmgpKF9wcmVhY3RSb3V0ZXIuTGluaywgX2V4dGVuZHMoe30sIHByb3BzLCB7ICdjbGFzcyc6IFtwcm9wcy5jbGFzcyB8fCBwcm9wcy5jbGFzc05hbWUsIG1hdGNoZXMgJiYgYWN0aXZlQ2xhc3NOYW1lXS5maWx0ZXIoQm9vbGVhbikuam9pbignICcpIH0pKTtcblx0XHR9XG5cdCk7XG59O1xuXG5leHBvcnRzLkxpbmsgPSBMaW5rO1xuZXhwb3J0cy5kZWZhdWx0ID0gTWF0Y2g7XG5cbk1hdGNoLkxpbmsgPSBMaW5rO1xuIiwiIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZShyZXF1aXJlKFwicHJlYWN0XCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcInByZWFjdFwiXSxlKTp0LnByZWFjdFJvdXRlcj1lKHQucHJlYWN0KX0odGhpcyxmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQsZSl7Zm9yKHZhciBuIGluIGUpdFtuXT1lW25dO3JldHVybiB0fWZ1bmN0aW9uIG4odCxlLG4pe3ZhciByLG89Lyg/OlxcPyhbXiNdKikpPygjLiopPyQvLHU9dC5tYXRjaChvKSxhPXt9O2lmKHUmJnVbMV0pZm9yKHZhciBwPXVbMV0uc3BsaXQoXCImXCIpLGM9MDtjPHAubGVuZ3RoO2MrKyl7dmFyIGY9cFtjXS5zcGxpdChcIj1cIik7YVtkZWNvZGVVUklDb21wb25lbnQoZlswXSldPWRlY29kZVVSSUNvbXBvbmVudChmLnNsaWNlKDEpLmpvaW4oXCI9XCIpKX10PWkodC5yZXBsYWNlKG8sXCJcIikpLGU9aShlfHxcIlwiKTtmb3IodmFyIGw9TWF0aC5tYXgodC5sZW5ndGgsZS5sZW5ndGgpLHM9MDtzPGw7cysrKWlmKGVbc10mJlwiOlwiPT09ZVtzXS5jaGFyQXQoMCkpe3ZhciBoPWVbc10ucmVwbGFjZSgvKF5cXDp8WysqP10rJCkvZyxcIlwiKSxkPShlW3NdLm1hdGNoKC9bKyo/XSskLyl8fEMpWzBdfHxcIlwiLGc9fmQuaW5kZXhPZihcIitcIiksbT1+ZC5pbmRleE9mKFwiKlwiKSx5PXRbc118fFwiXCI7aWYoIXkmJiFtJiYoZC5pbmRleE9mKFwiP1wiKTwwfHxnKSl7cj0hMTticmVha31pZihhW2hdPWRlY29kZVVSSUNvbXBvbmVudCh5KSxnfHxtKXthW2hdPXQuc2xpY2UocykubWFwKGRlY29kZVVSSUNvbXBvbmVudCkuam9pbihcIi9cIik7YnJlYWt9fWVsc2UgaWYoZVtzXSE9PXRbc10pe3I9ITE7YnJlYWt9cmV0dXJuKCEwPT09bi5kZWZhdWx0fHwhMSE9PXIpJiZhfWZ1bmN0aW9uIHIodCxlKXtyZXR1cm4gdC5yYW5rPGUucmFuaz8xOnQucmFuaz5lLnJhbms/LTE6dC5pbmRleC1lLmluZGV4fWZ1bmN0aW9uIG8odCxlKXtyZXR1cm4gdC5pbmRleD1lLHQucmFuaz1wKHQpLHQuYXR0cmlidXRlc31mdW5jdGlvbiBpKHQpe3JldHVybiB0LnJlcGxhY2UoLyheXFwvK3xcXC8rJCkvZyxcIlwiKS5zcGxpdChcIi9cIil9ZnVuY3Rpb24gdSh0KXtyZXR1cm5cIjpcIj09dC5jaGFyQXQoMCk/MStcIiorP1wiLmluZGV4T2YodC5jaGFyQXQodC5sZW5ndGgtMSkpfHw0OjV9ZnVuY3Rpb24gYSh0KXtyZXR1cm4gaSh0KS5tYXAodSkuam9pbihcIlwiKX1mdW5jdGlvbiBwKHQpe3JldHVybiB0LmF0dHJpYnV0ZXMuZGVmYXVsdD8wOmEodC5hdHRyaWJ1dGVzLnBhdGgpfWZ1bmN0aW9uIGModCl7cmV0dXJuIG51bGwhPXQuX19wcmVhY3RhdHRyX3x8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmbnVsbCE9dFtTeW1ib2wuZm9yKFwicHJlYWN0YXR0clwiKV19ZnVuY3Rpb24gZih0LGUpe3ZvaWQgMD09PWUmJihlPVwicHVzaFwiKSxSJiZSW2VdP1JbZV0odCk6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGhpc3RvcnkmJmhpc3RvcnlbZStcIlN0YXRlXCJdJiZoaXN0b3J5W2UrXCJTdGF0ZVwiXShudWxsLG51bGwsdCl9ZnVuY3Rpb24gbCgpe3ZhciB0O3JldHVybiB0PVImJlIubG9jYXRpb24/Ui5sb2NhdGlvbjpSJiZSLmdldEN1cnJlbnRMb2NhdGlvbj9SLmdldEN1cnJlbnRMb2NhdGlvbigpOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBsb2NhdGlvbj9sb2NhdGlvbjp4LFwiXCIrKHQucGF0aG5hbWV8fFwiXCIpKyh0LnNlYXJjaHx8XCJcIil9ZnVuY3Rpb24gcyh0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMSksXCJzdHJpbmdcIiE9dHlwZW9mIHQmJnQudXJsJiYoZT10LnJlcGxhY2UsdD10LnVybCksaCh0KSYmZih0LGU/XCJyZXBsYWNlXCI6XCJwdXNoXCIpLGQodCl9ZnVuY3Rpb24gaCh0KXtmb3IodmFyIGU9VS5sZW5ndGg7ZS0tOylpZihVW2VdLmNhblJvdXRlKHQpKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIGQodCl7Zm9yKHZhciBlPSExLG49MDtuPFUubGVuZ3RoO24rKykhMD09PVVbbl0ucm91dGVUbyh0KSYmKGU9ITApO2Zvcih2YXIgcj1rLmxlbmd0aDtyLS07KWtbcl0odCk7cmV0dXJuIGV9ZnVuY3Rpb24gZyh0KXtpZih0JiZ0LmdldEF0dHJpYnV0ZSl7dmFyIGU9dC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLG49dC5nZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIik7aWYoZSYmZS5tYXRjaCgvXlxcLy9nKSYmKCFufHxuLm1hdGNoKC9eXz9zZWxmJC9pKSkpcmV0dXJuIHMoZSl9fWZ1bmN0aW9uIG0odCl7aWYoMD09dC5idXR0b24pcmV0dXJuIGcodC5jdXJyZW50VGFyZ2V0fHx0LnRhcmdldHx8dGhpcykseSh0KX1mdW5jdGlvbiB5KHQpe3JldHVybiB0JiYodC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24mJnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksdC5zdG9wUHJvcGFnYXRpb24mJnQuc3RvcFByb3BhZ2F0aW9uKCksdC5wcmV2ZW50RGVmYXVsdCgpKSwhMX1mdW5jdGlvbiB2KHQpe2lmKCEodC5jdHJsS2V5fHx0Lm1ldGFLZXl8fHQuYWx0S2V5fHx0LnNoaWZ0S2V5fHwwIT09dC5idXR0b24pKXt2YXIgZT10LnRhcmdldDtkb3tpZihcIkFcIj09PShlLm5vZGVOYW1lK1wiXCIpLnRvVXBwZXJDYXNlKCkmJmUuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSYmYyhlKSl7aWYoZS5oYXNBdHRyaWJ1dGUoXCJuYXRpdmVcIikpcmV0dXJuO2lmKGcoZSkpcmV0dXJuIHkodCl9fXdoaWxlKGU9ZS5wYXJlbnROb2RlKX19ZnVuY3Rpb24gYigpe198fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBhZGRFdmVudExpc3RlbmVyJiYoUnx8YWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsZnVuY3Rpb24oKXtkKGwoKSl9KSxhZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIix2KSksXz0hMCl9dmFyIEM9e30sUj1udWxsLFU9W10saz1bXSx4PXt9LF89ITEsQT1mdW5jdGlvbihpKXtmdW5jdGlvbiB1KHQpe2kuY2FsbCh0aGlzLHQpLHQuaGlzdG9yeSYmKFI9dC5oaXN0b3J5KSx0aGlzLnN0YXRlPXt1cmw6dC51cmx8fGwoKX0sYigpfXJldHVybiBpJiYodS5fX3Byb3RvX189aSksdS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShpJiZpLnByb3RvdHlwZSksdS5wcm90b3R5cGUuY29uc3RydWN0b3I9dSx1LnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGU9ZnVuY3Rpb24odCl7cmV0dXJuITAhPT10LnN0YXRpY3x8KHQudXJsIT09dGhpcy5wcm9wcy51cmx8fHQub25DaGFuZ2UhPT10aGlzLnByb3BzLm9uQ2hhbmdlKX0sdS5wcm90b3R5cGUuY2FuUm91dGU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLHQsITEpLmxlbmd0aD4wfSx1LnByb3RvdHlwZS5yb3V0ZVRvPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9kaWRSb3V0ZT0hMSx0aGlzLnNldFN0YXRlKHt1cmw6dH0pLHRoaXMudXBkYXRpbmc/dGhpcy5jYW5Sb3V0ZSh0KToodGhpcy5mb3JjZVVwZGF0ZSgpLHRoaXMuX2RpZFJvdXRlKX0sdS5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50PWZ1bmN0aW9uKCl7VS5wdXNoKHRoaXMpLHRoaXMudXBkYXRpbmc9ITB9LHUucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztSJiYodGhpcy51bmxpc3Rlbj1SLmxpc3RlbihmdW5jdGlvbihlKXt0LnJvdXRlVG8oXCJcIisoZS5wYXRobmFtZXx8XCJcIikrKGUuc2VhcmNofHxcIlwiKSl9KSksdGhpcy51cGRhdGluZz0hMX0sdS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQ9ZnVuY3Rpb24oKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLnVubGlzdGVuJiZ0aGlzLnVubGlzdGVuKCksVS5zcGxpY2UoVS5pbmRleE9mKHRoaXMpLDEpfSx1LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVXBkYXRlPWZ1bmN0aW9uKCl7dGhpcy51cGRhdGluZz0hMH0sdS5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlPWZ1bmN0aW9uKCl7dGhpcy51cGRhdGluZz0hMX0sdS5wcm90b3R5cGUuZ2V0TWF0Y2hpbmdDaGlsZHJlbj1mdW5jdGlvbihpLHUsYSl7cmV0dXJuIGkuZmlsdGVyKG8pLnNvcnQocikubWFwKGZ1bmN0aW9uKHIpe3ZhciBvPW4odSxyLmF0dHJpYnV0ZXMucGF0aCxyLmF0dHJpYnV0ZXMpO2lmKG8pe2lmKCExIT09YSl7dmFyIGk9e3VybDp1LG1hdGNoZXM6b307cmV0dXJuIGUoaSxvKSxkZWxldGUgaS5yZWYsZGVsZXRlIGkua2V5LHQuY2xvbmVFbGVtZW50KHIsaSl9cmV0dXJuIHJ9fSkuZmlsdGVyKEJvb2xlYW4pfSx1LnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24odCxlKXt2YXIgbj10LmNoaWxkcmVuLHI9dC5vbkNoYW5nZSxvPWUudXJsLGk9dGhpcy5nZXRNYXRjaGluZ0NoaWxkcmVuKG4sbywhMCksdT1pWzBdfHxudWxsO3RoaXMuX2RpZFJvdXRlPSEhdTt2YXIgYT10aGlzLnByZXZpb3VzVXJsO3JldHVybiBvIT09YSYmKHRoaXMucHJldmlvdXNVcmw9byxcImZ1bmN0aW9uXCI9PXR5cGVvZiByJiZyKHtyb3V0ZXI6dGhpcyx1cmw6byxwcmV2aW91czphLGFjdGl2ZTppLGN1cnJlbnQ6dX0pKSx1fSx1fSh0LkNvbXBvbmVudCksST1mdW5jdGlvbihuKXtyZXR1cm4gdC5oKFwiYVwiLGUoe29uQ2xpY2s6bX0sbikpfSxMPWZ1bmN0aW9uKGUpe3JldHVybiB0LmgoZS5jb21wb25lbnQsZSl9O3JldHVybiBBLnN1YnNjcmliZXJzPWssQS5nZXRDdXJyZW50VXJsPWwsQS5yb3V0ZT1zLEEuUm91dGVyPUEsQS5Sb3V0ZT1MLEEuTGluaz1JLEF9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWFjdC1yb3V0ZXIuanMubWFwXG4iLCIhZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGZ1bmN0aW9uIFZOb2RlKCkge31cbiAgICBmdW5jdGlvbiBoKG5vZGVOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHZhciBsYXN0U2ltcGxlLCBjaGlsZCwgc2ltcGxlLCBpLCBjaGlsZHJlbiA9IEVNUFRZX0NISUxEUkVOO1xuICAgICAgICBmb3IgKGkgPSBhcmd1bWVudHMubGVuZ3RoOyBpLS0gPiAyOyApIHN0YWNrLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMgJiYgbnVsbCAhPSBhdHRyaWJ1dGVzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoIXN0YWNrLmxlbmd0aCkgc3RhY2sucHVzaChhdHRyaWJ1dGVzLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLmNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIGlmICgoY2hpbGQgPSBzdGFjay5wb3AoKSkgJiYgdm9pZCAwICE9PSBjaGlsZC5wb3ApIGZvciAoaSA9IGNoaWxkLmxlbmd0aDsgaS0tOyApIHN0YWNrLnB1c2goY2hpbGRbaV0pOyBlbHNlIHtcbiAgICAgICAgICAgIGlmICgnYm9vbGVhbicgPT0gdHlwZW9mIGNoaWxkKSBjaGlsZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoc2ltcGxlID0gJ2Z1bmN0aW9uJyAhPSB0eXBlb2Ygbm9kZU5hbWUpIGlmIChudWxsID09IGNoaWxkKSBjaGlsZCA9ICcnOyBlbHNlIGlmICgnbnVtYmVyJyA9PSB0eXBlb2YgY2hpbGQpIGNoaWxkID0gU3RyaW5nKGNoaWxkKTsgZWxzZSBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIGNoaWxkKSBzaW1wbGUgPSAhMTtcbiAgICAgICAgICAgIGlmIChzaW1wbGUgJiYgbGFzdFNpbXBsZSkgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0gKz0gY2hpbGQ7IGVsc2UgaWYgKGNoaWxkcmVuID09PSBFTVBUWV9DSElMRFJFTikgY2hpbGRyZW4gPSBbIGNoaWxkIF07IGVsc2UgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgICAgICBsYXN0U2ltcGxlID0gc2ltcGxlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwID0gbmV3IFZOb2RlKCk7XG4gICAgICAgIHAubm9kZU5hbWUgPSBub2RlTmFtZTtcbiAgICAgICAgcC5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICBwLmF0dHJpYnV0ZXMgPSBudWxsID09IGF0dHJpYnV0ZXMgPyB2b2lkIDAgOiBhdHRyaWJ1dGVzO1xuICAgICAgICBwLmtleSA9IG51bGwgPT0gYXR0cmlidXRlcyA/IHZvaWQgMCA6IGF0dHJpYnV0ZXMua2V5O1xuICAgICAgICBpZiAodm9pZCAwICE9PSBvcHRpb25zLnZub2RlKSBvcHRpb25zLnZub2RlKHApO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXh0ZW5kKG9iaiwgcHJvcHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBwcm9wcykgb2JqW2ldID0gcHJvcHNbaV07XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb25lRWxlbWVudCh2bm9kZSwgcHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIGgodm5vZGUubm9kZU5hbWUsIGV4dGVuZChleHRlbmQoe30sIHZub2RlLmF0dHJpYnV0ZXMpLCBwcm9wcyksIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogdm5vZGUuY2hpbGRyZW4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlUmVuZGVyKGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoIWNvbXBvbmVudC5fX2QgJiYgKGNvbXBvbmVudC5fX2QgPSAhMCkgJiYgMSA9PSBpdGVtcy5wdXNoKGNvbXBvbmVudCkpIChvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nIHx8IGRlZmVyKShyZXJlbmRlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcmVuZGVyKCkge1xuICAgICAgICB2YXIgcCwgbGlzdCA9IGl0ZW1zO1xuICAgICAgICBpdGVtcyA9IFtdO1xuICAgICAgICB3aGlsZSAocCA9IGxpc3QucG9wKCkpIGlmIChwLl9fZCkgcmVuZGVyQ29tcG9uZW50KHApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1NhbWVOb2RlVHlwZShub2RlLCB2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgICAgIGlmICgnc3RyaW5nJyA9PSB0eXBlb2Ygdm5vZGUgfHwgJ251bWJlcicgPT0gdHlwZW9mIHZub2RlKSByZXR1cm4gdm9pZCAwICE9PSBub2RlLnNwbGl0VGV4dDtcbiAgICAgICAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB2bm9kZS5ub2RlTmFtZSkgcmV0dXJuICFub2RlLl9jb21wb25lbnRDb25zdHJ1Y3RvciAmJiBpc05hbWVkTm9kZShub2RlLCB2bm9kZS5ub2RlTmFtZSk7IGVsc2UgcmV0dXJuIGh5ZHJhdGluZyB8fCBub2RlLl9jb21wb25lbnRDb25zdHJ1Y3RvciA9PT0gdm5vZGUubm9kZU5hbWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTmFtZWROb2RlKG5vZGUsIG5vZGVOYW1lKSB7XG4gICAgICAgIHJldHVybiBub2RlLl9fbiA9PT0gbm9kZU5hbWUgfHwgbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXROb2RlUHJvcHModm5vZGUpIHtcbiAgICAgICAgdmFyIHByb3BzID0gZXh0ZW5kKHt9LCB2bm9kZS5hdHRyaWJ1dGVzKTtcbiAgICAgICAgcHJvcHMuY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHZub2RlLm5vZGVOYW1lLmRlZmF1bHRQcm9wcztcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gZGVmYXVsdFByb3BzKSBmb3IgKHZhciBpIGluIGRlZmF1bHRQcm9wcykgaWYgKHZvaWQgMCA9PT0gcHJvcHNbaV0pIHByb3BzW2ldID0gZGVmYXVsdFByb3BzW2ldO1xuICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU5vZGUobm9kZU5hbWUsIGlzU3ZnKSB7XG4gICAgICAgIHZhciBub2RlID0gaXNTdmcgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbm9kZU5hbWUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSk7XG4gICAgICAgIG5vZGUuX19uID0gbm9kZU5hbWU7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcbiAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRBY2Nlc3Nvcihub2RlLCBuYW1lLCBvbGQsIHZhbHVlLCBpc1N2Zykge1xuICAgICAgICBpZiAoJ2NsYXNzTmFtZScgPT09IG5hbWUpIG5hbWUgPSAnY2xhc3MnO1xuICAgICAgICBpZiAoJ2tleScgPT09IG5hbWUpIDsgZWxzZSBpZiAoJ3JlZicgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChvbGQpIG9sZChudWxsKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkgdmFsdWUobm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoJ2NsYXNzJyA9PT0gbmFtZSAmJiAhaXNTdmcpIG5vZGUuY2xhc3NOYW1lID0gdmFsdWUgfHwgJyc7IGVsc2UgaWYgKCdzdHlsZScgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIGlmICghdmFsdWUgfHwgJ3N0cmluZycgPT0gdHlwZW9mIHZhbHVlIHx8ICdzdHJpbmcnID09IHR5cGVvZiBvbGQpIG5vZGUuc3R5bGUuY3NzVGV4dCA9IHZhbHVlIHx8ICcnO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmICdvYmplY3QnID09IHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICgnc3RyaW5nJyAhPSB0eXBlb2Ygb2xkKSBmb3IgKHZhciBpIGluIG9sZCkgaWYgKCEoaSBpbiB2YWx1ZSkpIG5vZGUuc3R5bGVbaV0gPSAnJztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHZhbHVlKSBub2RlLnN0eWxlW2ldID0gJ251bWJlcicgPT0gdHlwZW9mIHZhbHVlW2ldICYmICExID09PSBJU19OT05fRElNRU5TSU9OQUwudGVzdChpKSA/IHZhbHVlW2ldICsgJ3B4JyA6IHZhbHVlW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCdkYW5nZXJvdXNseVNldElubmVySFRNTCcgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkgbm9kZS5pbm5lckhUTUwgPSB2YWx1ZS5fX2h0bWwgfHwgJyc7XG4gICAgICAgIH0gZWxzZSBpZiAoJ28nID09IG5hbWVbMF0gJiYgJ24nID09IG5hbWVbMV0pIHtcbiAgICAgICAgICAgIHZhciB1c2VDYXB0dXJlID0gbmFtZSAhPT0gKG5hbWUgPSBuYW1lLnJlcGxhY2UoL0NhcHR1cmUkLywgJycpKTtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDIpO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvbGQpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBldmVudFByb3h5LCB1c2VDYXB0dXJlKTtcbiAgICAgICAgICAgIH0gZWxzZSBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgZXZlbnRQcm94eSwgdXNlQ2FwdHVyZSk7XG4gICAgICAgICAgICAobm9kZS5fX2wgfHwgKG5vZGUuX19sID0ge30pKVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKCdsaXN0JyAhPT0gbmFtZSAmJiAndHlwZScgIT09IG5hbWUgJiYgIWlzU3ZnICYmIG5hbWUgaW4gbm9kZSkge1xuICAgICAgICAgICAgc2V0UHJvcGVydHkobm9kZSwgbmFtZSwgbnVsbCA9PSB2YWx1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgICAgICAgaWYgKG51bGwgPT0gdmFsdWUgfHwgITEgPT09IHZhbHVlKSBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBucyA9IGlzU3ZnICYmIG5hbWUgIT09IChuYW1lID0gbmFtZS5yZXBsYWNlKC9eeGxpbms6Py8sICcnKSk7XG4gICAgICAgICAgICBpZiAobnVsbCA9PSB2YWx1ZSB8fCAhMSA9PT0gdmFsdWUpIGlmIChucykgbm9kZS5yZW1vdmVBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIG5hbWUudG9Mb3dlckNhc2UoKSk7IGVsc2Ugbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7IGVsc2UgaWYgKCdmdW5jdGlvbicgIT0gdHlwZW9mIHZhbHVlKSBpZiAobnMpIG5vZGUuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBuYW1lLnRvTG93ZXJDYXNlKCksIHZhbHVlKTsgZWxzZSBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0UHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5vZGVbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gICAgZnVuY3Rpb24gZXZlbnRQcm94eShlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fbFtlLnR5cGVdKG9wdGlvbnMuZXZlbnQgJiYgb3B0aW9ucy5ldmVudChlKSB8fCBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmx1c2hNb3VudHMoKSB7XG4gICAgICAgIHZhciBjO1xuICAgICAgICB3aGlsZSAoYyA9IG1vdW50cy5wb3AoKSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWZ0ZXJNb3VudCkgb3B0aW9ucy5hZnRlck1vdW50KGMpO1xuICAgICAgICAgICAgaWYgKGMuY29tcG9uZW50RGlkTW91bnQpIGMuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaWZmKGRvbSwgdm5vZGUsIGNvbnRleHQsIG1vdW50QWxsLCBwYXJlbnQsIGNvbXBvbmVudFJvb3QpIHtcbiAgICAgICAgaWYgKCFkaWZmTGV2ZWwrKykge1xuICAgICAgICAgICAgaXNTdmdNb2RlID0gbnVsbCAhPSBwYXJlbnQgJiYgdm9pZCAwICE9PSBwYXJlbnQub3duZXJTVkdFbGVtZW50O1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gbnVsbCAhPSBkb20gJiYgISgnX19wcmVhY3RhdHRyXycgaW4gZG9tKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmV0ID0gaWRpZmYoZG9tLCB2bm9kZSwgY29udGV4dCwgbW91bnRBbGwsIGNvbXBvbmVudFJvb3QpO1xuICAgICAgICBpZiAocGFyZW50ICYmIHJldC5wYXJlbnROb2RlICE9PSBwYXJlbnQpIHBhcmVudC5hcHBlbmRDaGlsZChyZXQpO1xuICAgICAgICBpZiAoIS0tZGlmZkxldmVsKSB7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSAhMTtcbiAgICAgICAgICAgIGlmICghY29tcG9uZW50Um9vdCkgZmx1c2hNb3VudHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpZGlmZihkb20sIHZub2RlLCBjb250ZXh0LCBtb3VudEFsbCwgY29tcG9uZW50Um9vdCkge1xuICAgICAgICB2YXIgb3V0ID0gZG9tLCBwcmV2U3ZnTW9kZSA9IGlzU3ZnTW9kZTtcbiAgICAgICAgaWYgKG51bGwgPT0gdm5vZGUgfHwgJ2Jvb2xlYW4nID09IHR5cGVvZiB2bm9kZSkgdm5vZGUgPSAnJztcbiAgICAgICAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB2bm9kZSB8fCAnbnVtYmVyJyA9PSB0eXBlb2Ygdm5vZGUpIHtcbiAgICAgICAgICAgIGlmIChkb20gJiYgdm9pZCAwICE9PSBkb20uc3BsaXRUZXh0ICYmIGRvbS5wYXJlbnROb2RlICYmICghZG9tLl9jb21wb25lbnQgfHwgY29tcG9uZW50Um9vdCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tLm5vZGVWYWx1ZSAhPSB2bm9kZSkgZG9tLm5vZGVWYWx1ZSA9IHZub2RlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2bm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tLnBhcmVudE5vZGUpIGRvbS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChvdXQsIGRvbSk7XG4gICAgICAgICAgICAgICAgICAgIHJlY29sbGVjdE5vZGVUcmVlKGRvbSwgITApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dC5fX3ByZWFjdGF0dHJfID0gITA7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIHZhciB2bm9kZU5hbWUgPSB2bm9kZS5ub2RlTmFtZTtcbiAgICAgICAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHZub2RlTmFtZSkgcmV0dXJuIGJ1aWxkQ29tcG9uZW50RnJvbVZOb2RlKGRvbSwgdm5vZGUsIGNvbnRleHQsIG1vdW50QWxsKTtcbiAgICAgICAgaXNTdmdNb2RlID0gJ3N2ZycgPT09IHZub2RlTmFtZSA/ICEwIDogJ2ZvcmVpZ25PYmplY3QnID09PSB2bm9kZU5hbWUgPyAhMSA6IGlzU3ZnTW9kZTtcbiAgICAgICAgdm5vZGVOYW1lID0gU3RyaW5nKHZub2RlTmFtZSk7XG4gICAgICAgIGlmICghZG9tIHx8ICFpc05hbWVkTm9kZShkb20sIHZub2RlTmFtZSkpIHtcbiAgICAgICAgICAgIG91dCA9IGNyZWF0ZU5vZGUodm5vZGVOYW1lLCBpc1N2Z01vZGUpO1xuICAgICAgICAgICAgaWYgKGRvbSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChkb20uZmlyc3RDaGlsZCkgb3V0LmFwcGVuZENoaWxkKGRvbS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9tLnBhcmVudE5vZGUpIGRvbS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChvdXQsIGRvbSk7XG4gICAgICAgICAgICAgICAgcmVjb2xsZWN0Tm9kZVRyZWUoZG9tLCAhMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZjID0gb3V0LmZpcnN0Q2hpbGQsIHByb3BzID0gb3V0Ll9fcHJlYWN0YXR0cl8sIHZjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICBpZiAobnVsbCA9PSBwcm9wcykge1xuICAgICAgICAgICAgcHJvcHMgPSBvdXQuX19wcmVhY3RhdHRyXyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgYSA9IG91dC5hdHRyaWJ1dGVzLCBpID0gYS5sZW5ndGg7IGktLTsgKSBwcm9wc1thW2ldLm5hbWVdID0gYVtpXS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWh5ZHJhdGluZyAmJiB2Y2hpbGRyZW4gJiYgMSA9PT0gdmNoaWxkcmVuLmxlbmd0aCAmJiAnc3RyaW5nJyA9PSB0eXBlb2YgdmNoaWxkcmVuWzBdICYmIG51bGwgIT0gZmMgJiYgdm9pZCAwICE9PSBmYy5zcGxpdFRleHQgJiYgbnVsbCA9PSBmYy5uZXh0U2libGluZykge1xuICAgICAgICAgICAgaWYgKGZjLm5vZGVWYWx1ZSAhPSB2Y2hpbGRyZW5bMF0pIGZjLm5vZGVWYWx1ZSA9IHZjaGlsZHJlblswXTtcbiAgICAgICAgfSBlbHNlIGlmICh2Y2hpbGRyZW4gJiYgdmNoaWxkcmVuLmxlbmd0aCB8fCBudWxsICE9IGZjKSBpbm5lckRpZmZOb2RlKG91dCwgdmNoaWxkcmVuLCBjb250ZXh0LCBtb3VudEFsbCwgaHlkcmF0aW5nIHx8IG51bGwgIT0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpO1xuICAgICAgICBkaWZmQXR0cmlidXRlcyhvdXQsIHZub2RlLmF0dHJpYnV0ZXMsIHByb3BzKTtcbiAgICAgICAgaXNTdmdNb2RlID0gcHJldlN2Z01vZGU7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlubmVyRGlmZk5vZGUoZG9tLCB2Y2hpbGRyZW4sIGNvbnRleHQsIG1vdW50QWxsLCBpc0h5ZHJhdGluZykge1xuICAgICAgICB2YXIgaiwgYywgZiwgdmNoaWxkLCBjaGlsZCwgb3JpZ2luYWxDaGlsZHJlbiA9IGRvbS5jaGlsZE5vZGVzLCBjaGlsZHJlbiA9IFtdLCBrZXllZCA9IHt9LCBrZXllZExlbiA9IDAsIG1pbiA9IDAsIGxlbiA9IG9yaWdpbmFsQ2hpbGRyZW4ubGVuZ3RoLCBjaGlsZHJlbkxlbiA9IDAsIHZsZW4gPSB2Y2hpbGRyZW4gPyB2Y2hpbGRyZW4ubGVuZ3RoIDogMDtcbiAgICAgICAgaWYgKDAgIT09IGxlbikgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIF9jaGlsZCA9IG9yaWdpbmFsQ2hpbGRyZW5baV0sIHByb3BzID0gX2NoaWxkLl9fcHJlYWN0YXR0cl8sIGtleSA9IHZsZW4gJiYgcHJvcHMgPyBfY2hpbGQuX2NvbXBvbmVudCA/IF9jaGlsZC5fY29tcG9uZW50Ll9fayA6IHByb3BzLmtleSA6IG51bGw7XG4gICAgICAgICAgICBpZiAobnVsbCAhPSBrZXkpIHtcbiAgICAgICAgICAgICAgICBrZXllZExlbisrO1xuICAgICAgICAgICAgICAgIGtleWVkW2tleV0gPSBfY2hpbGQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BzIHx8ICh2b2lkIDAgIT09IF9jaGlsZC5zcGxpdFRleHQgPyBpc0h5ZHJhdGluZyA/IF9jaGlsZC5ub2RlVmFsdWUudHJpbSgpIDogITAgOiBpc0h5ZHJhdGluZykpIGNoaWxkcmVuW2NoaWxkcmVuTGVuKytdID0gX2NoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGlmICgwICE9PSB2bGVuKSBmb3IgKHZhciBpID0gMDsgaSA8IHZsZW47IGkrKykge1xuICAgICAgICAgICAgdmNoaWxkID0gdmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgY2hpbGQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGtleSA9IHZjaGlsZC5rZXk7XG4gICAgICAgICAgICBpZiAobnVsbCAhPSBrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ZWRMZW4gJiYgdm9pZCAwICE9PSBrZXllZFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0ga2V5ZWRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAga2V5ZWRba2V5XSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAga2V5ZWRMZW4tLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFjaGlsZCAmJiBtaW4gPCBjaGlsZHJlbkxlbikgZm9yIChqID0gbWluOyBqIDwgY2hpbGRyZW5MZW47IGorKykgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW5bal0gJiYgaXNTYW1lTm9kZVR5cGUoYyA9IGNoaWxkcmVuW2pdLCB2Y2hpbGQsIGlzSHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gYztcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltqXSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gY2hpbGRyZW5MZW4gLSAxKSBjaGlsZHJlbkxlbi0tO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSBtaW4pIG1pbisrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQgPSBpZGlmZihjaGlsZCwgdmNoaWxkLCBjb250ZXh0LCBtb3VudEFsbCk7XG4gICAgICAgICAgICBmID0gb3JpZ2luYWxDaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZCAhPT0gZG9tICYmIGNoaWxkICE9PSBmKSBpZiAobnVsbCA9PSBmKSBkb20uYXBwZW5kQ2hpbGQoY2hpbGQpOyBlbHNlIGlmIChjaGlsZCA9PT0gZi5uZXh0U2libGluZykgcmVtb3ZlTm9kZShmKTsgZWxzZSBkb20uaW5zZXJ0QmVmb3JlKGNoaWxkLCBmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ZWRMZW4pIGZvciAodmFyIGkgaW4ga2V5ZWQpIGlmICh2b2lkIDAgIT09IGtleWVkW2ldKSByZWNvbGxlY3ROb2RlVHJlZShrZXllZFtpXSwgITEpO1xuICAgICAgICB3aGlsZSAobWluIDw9IGNoaWxkcmVuTGVuKSBpZiAodm9pZCAwICE9PSAoY2hpbGQgPSBjaGlsZHJlbltjaGlsZHJlbkxlbi0tXSkpIHJlY29sbGVjdE5vZGVUcmVlKGNoaWxkLCAhMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY29sbGVjdE5vZGVUcmVlKG5vZGUsIHVubW91bnRPbmx5KSB7XG4gICAgICAgIHZhciBjb21wb25lbnQgPSBub2RlLl9jb21wb25lbnQ7XG4gICAgICAgIGlmIChjb21wb25lbnQpIHVubW91bnRDb21wb25lbnQoY29tcG9uZW50KTsgZWxzZSB7XG4gICAgICAgICAgICBpZiAobnVsbCAhPSBub2RlLl9fcHJlYWN0YXR0cl8gJiYgbm9kZS5fX3ByZWFjdGF0dHJfLnJlZikgbm9kZS5fX3ByZWFjdGF0dHJfLnJlZihudWxsKTtcbiAgICAgICAgICAgIGlmICghMSA9PT0gdW5tb3VudE9ubHkgfHwgbnVsbCA9PSBub2RlLl9fcHJlYWN0YXR0cl8pIHJlbW92ZU5vZGUobm9kZSk7XG4gICAgICAgICAgICByZW1vdmVDaGlsZHJlbihub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVDaGlsZHJlbihub2RlKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICByZWNvbGxlY3ROb2RlVHJlZShub2RlLCAhMCk7XG4gICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaWZmQXR0cmlidXRlcyhkb20sIGF0dHJzLCBvbGQpIHtcbiAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgIGZvciAobmFtZSBpbiBvbGQpIGlmICgoIWF0dHJzIHx8IG51bGwgPT0gYXR0cnNbbmFtZV0pICYmIG51bGwgIT0gb2xkW25hbWVdKSBzZXRBY2Nlc3Nvcihkb20sIG5hbWUsIG9sZFtuYW1lXSwgb2xkW25hbWVdID0gdm9pZCAwLCBpc1N2Z01vZGUpO1xuICAgICAgICBmb3IgKG5hbWUgaW4gYXR0cnMpIGlmICghKCdjaGlsZHJlbicgPT09IG5hbWUgfHwgJ2lubmVySFRNTCcgPT09IG5hbWUgfHwgbmFtZSBpbiBvbGQgJiYgYXR0cnNbbmFtZV0gPT09ICgndmFsdWUnID09PSBuYW1lIHx8ICdjaGVja2VkJyA9PT0gbmFtZSA/IGRvbVtuYW1lXSA6IG9sZFtuYW1lXSkpKSBzZXRBY2Nlc3Nvcihkb20sIG5hbWUsIG9sZFtuYW1lXSwgb2xkW25hbWVdID0gYXR0cnNbbmFtZV0sIGlzU3ZnTW9kZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbGxlY3RDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgICAgIHZhciBuYW1lID0gY29tcG9uZW50LmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIChjb21wb25lbnRzW25hbWVdIHx8IChjb21wb25lbnRzW25hbWVdID0gW10pKS5wdXNoKGNvbXBvbmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudChDdG9yLCBwcm9wcywgY29udGV4dCkge1xuICAgICAgICB2YXIgaW5zdCwgbGlzdCA9IGNvbXBvbmVudHNbQ3Rvci5uYW1lXTtcbiAgICAgICAgaWYgKEN0b3IucHJvdG90eXBlICYmIEN0b3IucHJvdG90eXBlLnJlbmRlcikge1xuICAgICAgICAgICAgaW5zdCA9IG5ldyBDdG9yKHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIENvbXBvbmVudC5jYWxsKGluc3QsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluc3QgPSBuZXcgQ29tcG9uZW50KHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGluc3QuY29uc3RydWN0b3IgPSBDdG9yO1xuICAgICAgICAgICAgaW5zdC5yZW5kZXIgPSBkb1JlbmRlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdCkgZm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoOyBpLS07ICkgaWYgKGxpc3RbaV0uY29uc3RydWN0b3IgPT09IEN0b3IpIHtcbiAgICAgICAgICAgIGluc3QuX19iID0gbGlzdFtpXS5fX2I7XG4gICAgICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkb1JlbmRlcihwcm9wcywgc3RhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRDb21wb25lbnRQcm9wcyhjb21wb25lbnQsIHByb3BzLCBvcHRzLCBjb250ZXh0LCBtb3VudEFsbCkge1xuICAgICAgICBpZiAoIWNvbXBvbmVudC5fX3gpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5fX3ggPSAhMDtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuX19yID0gcHJvcHMucmVmKSBkZWxldGUgcHJvcHMucmVmO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5fX2sgPSBwcm9wcy5rZXkpIGRlbGV0ZSBwcm9wcy5rZXk7XG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudC5iYXNlIHx8IG1vdW50QWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5jb21wb25lbnRXaWxsTW91bnQpIGNvbXBvbmVudC5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpIGNvbXBvbmVudC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQgIT09IGNvbXBvbmVudC5jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnQuX19jKSBjb21wb25lbnQuX19jID0gY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb21wb25lbnQuX19wKSBjb21wb25lbnQuX19wID0gY29tcG9uZW50LnByb3BzO1xuICAgICAgICAgICAgY29tcG9uZW50LnByb3BzID0gcHJvcHM7XG4gICAgICAgICAgICBjb21wb25lbnQuX194ID0gITE7XG4gICAgICAgICAgICBpZiAoMCAhPT0gb3B0cykgaWYgKDEgPT09IG9wdHMgfHwgITEgIT09IG9wdGlvbnMuc3luY0NvbXBvbmVudFVwZGF0ZXMgfHwgIWNvbXBvbmVudC5iYXNlKSByZW5kZXJDb21wb25lbnQoY29tcG9uZW50LCAxLCBtb3VudEFsbCk7IGVsc2UgZW5xdWV1ZVJlbmRlcihjb21wb25lbnQpO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5fX3IpIGNvbXBvbmVudC5fX3IoY29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJDb21wb25lbnQoY29tcG9uZW50LCBvcHRzLCBtb3VudEFsbCwgaXNDaGlsZCkge1xuICAgICAgICBpZiAoIWNvbXBvbmVudC5fX3gpIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJlZCwgaW5zdCwgY2Jhc2UsIHByb3BzID0gY29tcG9uZW50LnByb3BzLCBzdGF0ZSA9IGNvbXBvbmVudC5zdGF0ZSwgY29udGV4dCA9IGNvbXBvbmVudC5jb250ZXh0LCBwcmV2aW91c1Byb3BzID0gY29tcG9uZW50Ll9fcCB8fCBwcm9wcywgcHJldmlvdXNTdGF0ZSA9IGNvbXBvbmVudC5fX3MgfHwgc3RhdGUsIHByZXZpb3VzQ29udGV4dCA9IGNvbXBvbmVudC5fX2MgfHwgY29udGV4dCwgaXNVcGRhdGUgPSBjb21wb25lbnQuYmFzZSwgbmV4dEJhc2UgPSBjb21wb25lbnQuX19iLCBpbml0aWFsQmFzZSA9IGlzVXBkYXRlIHx8IG5leHRCYXNlLCBpbml0aWFsQ2hpbGRDb21wb25lbnQgPSBjb21wb25lbnQuX2NvbXBvbmVudCwgc2tpcCA9ICExO1xuICAgICAgICAgICAgaWYgKGlzVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnByb3BzID0gcHJldmlvdXNQcm9wcztcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuc3RhdGUgPSBwcmV2aW91c1N0YXRlO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgICAgICAgICAgIGlmICgyICE9PSBvcHRzICYmIGNvbXBvbmVudC5zaG91bGRDb21wb25lbnRVcGRhdGUgJiYgITEgPT09IGNvbXBvbmVudC5zaG91bGRDb21wb25lbnRVcGRhdGUocHJvcHMsIHN0YXRlLCBjb250ZXh0KSkgc2tpcCA9ICEwOyBlbHNlIGlmIChjb21wb25lbnQuY29tcG9uZW50V2lsbFVwZGF0ZSkgY29tcG9uZW50LmNvbXBvbmVudFdpbGxVcGRhdGUocHJvcHMsIHN0YXRlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQucHJvcHMgPSBwcm9wcztcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnQuX19wID0gY29tcG9uZW50Ll9fcyA9IGNvbXBvbmVudC5fX2MgPSBjb21wb25lbnQuX19iID0gbnVsbDtcbiAgICAgICAgICAgIGNvbXBvbmVudC5fX2QgPSAhMTtcbiAgICAgICAgICAgIGlmICghc2tpcCkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkID0gY29tcG9uZW50LnJlbmRlcihwcm9wcywgc3RhdGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQuZ2V0Q2hpbGRDb250ZXh0KSBjb250ZXh0ID0gZXh0ZW5kKGV4dGVuZCh7fSwgY29udGV4dCksIGNvbXBvbmVudC5nZXRDaGlsZENvbnRleHQoKSk7XG4gICAgICAgICAgICAgICAgdmFyIHRvVW5tb3VudCwgYmFzZSwgY2hpbGRDb21wb25lbnQgPSByZW5kZXJlZCAmJiByZW5kZXJlZC5ub2RlTmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgY2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkUHJvcHMgPSBnZXROb2RlUHJvcHMocmVuZGVyZWQpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0ID0gaW5pdGlhbENoaWxkQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdCAmJiBpbnN0LmNvbnN0cnVjdG9yID09PSBjaGlsZENvbXBvbmVudCAmJiBjaGlsZFByb3BzLmtleSA9PSBpbnN0Ll9faykgc2V0Q29tcG9uZW50UHJvcHMoaW5zdCwgY2hpbGRQcm9wcywgMSwgY29udGV4dCwgITEpOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvVW5tb3VudCA9IGluc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuX2NvbXBvbmVudCA9IGluc3QgPSBjcmVhdGVDb21wb25lbnQoY2hpbGRDb21wb25lbnQsIGNoaWxkUHJvcHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdC5fX2IgPSBpbnN0Ll9fYiB8fCBuZXh0QmFzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3QuX191ID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q29tcG9uZW50UHJvcHMoaW5zdCwgY2hpbGRQcm9wcywgMCwgY29udGV4dCwgITEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyQ29tcG9uZW50KGluc3QsIDEsIG1vdW50QWxsLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGluc3QuYmFzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYmFzZSA9IGluaXRpYWxCYXNlO1xuICAgICAgICAgICAgICAgICAgICB0b1VubW91bnQgPSBpbml0aWFsQ2hpbGRDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b1VubW91bnQpIGNiYXNlID0gY29tcG9uZW50Ll9jb21wb25lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbEJhc2UgfHwgMSA9PT0gb3B0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNiYXNlKSBjYmFzZS5fY29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UgPSBkaWZmKGNiYXNlLCByZW5kZXJlZCwgY29udGV4dCwgbW91bnRBbGwgfHwgIWlzVXBkYXRlLCBpbml0aWFsQmFzZSAmJiBpbml0aWFsQmFzZS5wYXJlbnROb2RlLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxCYXNlICYmIGJhc2UgIT09IGluaXRpYWxCYXNlICYmIGluc3QgIT09IGluaXRpYWxDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVBhcmVudCA9IGluaXRpYWxCYXNlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlUGFyZW50ICYmIGJhc2UgIT09IGJhc2VQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VQYXJlbnQucmVwbGFjZUNoaWxkKGJhc2UsIGluaXRpYWxCYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdG9Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbEJhc2UuX2NvbXBvbmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb2xsZWN0Tm9kZVRyZWUoaW5pdGlhbEJhc2UsICExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9Vbm1vdW50KSB1bm1vdW50Q29tcG9uZW50KHRvVW5tb3VudCk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmJhc2UgPSBiYXNlO1xuICAgICAgICAgICAgICAgIGlmIChiYXNlICYmICFpc0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRSZWYgPSBjb21wb25lbnQsIHQgPSBjb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0ID0gdC5fX3UpIChjb21wb25lbnRSZWYgPSB0KS5iYXNlID0gYmFzZTtcbiAgICAgICAgICAgICAgICAgICAgYmFzZS5fY29tcG9uZW50ID0gY29tcG9uZW50UmVmO1xuICAgICAgICAgICAgICAgICAgICBiYXNlLl9jb21wb25lbnRDb25zdHJ1Y3RvciA9IGNvbXBvbmVudFJlZi5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzVXBkYXRlIHx8IG1vdW50QWxsKSBtb3VudHMudW5zaGlmdChjb21wb25lbnQpOyBlbHNlIGlmICghc2tpcCkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQuY29tcG9uZW50RGlkVXBkYXRlKSBjb21wb25lbnQuY29tcG9uZW50RGlkVXBkYXRlKHByZXZpb3VzUHJvcHMsIHByZXZpb3VzU3RhdGUsIHByZXZpb3VzQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWZ0ZXJVcGRhdGUpIG9wdGlvbnMuYWZ0ZXJVcGRhdGUoY29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChudWxsICE9IGNvbXBvbmVudC5fX2gpIHdoaWxlIChjb21wb25lbnQuX19oLmxlbmd0aCkgY29tcG9uZW50Ll9faC5wb3AoKS5jYWxsKGNvbXBvbmVudCk7XG4gICAgICAgICAgICBpZiAoIWRpZmZMZXZlbCAmJiAhaXNDaGlsZCkgZmx1c2hNb3VudHMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBidWlsZENvbXBvbmVudEZyb21WTm9kZShkb20sIHZub2RlLCBjb250ZXh0LCBtb3VudEFsbCkge1xuICAgICAgICB2YXIgYyA9IGRvbSAmJiBkb20uX2NvbXBvbmVudCwgb3JpZ2luYWxDb21wb25lbnQgPSBjLCBvbGREb20gPSBkb20sIGlzRGlyZWN0T3duZXIgPSBjICYmIGRvbS5fY29tcG9uZW50Q29uc3RydWN0b3IgPT09IHZub2RlLm5vZGVOYW1lLCBpc093bmVyID0gaXNEaXJlY3RPd25lciwgcHJvcHMgPSBnZXROb2RlUHJvcHModm5vZGUpO1xuICAgICAgICB3aGlsZSAoYyAmJiAhaXNPd25lciAmJiAoYyA9IGMuX191KSkgaXNPd25lciA9IGMuY29uc3RydWN0b3IgPT09IHZub2RlLm5vZGVOYW1lO1xuICAgICAgICBpZiAoYyAmJiBpc093bmVyICYmICghbW91bnRBbGwgfHwgYy5fY29tcG9uZW50KSkge1xuICAgICAgICAgICAgc2V0Q29tcG9uZW50UHJvcHMoYywgcHJvcHMsIDMsIGNvbnRleHQsIG1vdW50QWxsKTtcbiAgICAgICAgICAgIGRvbSA9IGMuYmFzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbENvbXBvbmVudCAmJiAhaXNEaXJlY3RPd25lcikge1xuICAgICAgICAgICAgICAgIHVubW91bnRDb21wb25lbnQob3JpZ2luYWxDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIGRvbSA9IG9sZERvbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjID0gY3JlYXRlQ29tcG9uZW50KHZub2RlLm5vZGVOYW1lLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoZG9tICYmICFjLl9fYikge1xuICAgICAgICAgICAgICAgIGMuX19iID0gZG9tO1xuICAgICAgICAgICAgICAgIG9sZERvbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDb21wb25lbnRQcm9wcyhjLCBwcm9wcywgMSwgY29udGV4dCwgbW91bnRBbGwpO1xuICAgICAgICAgICAgZG9tID0gYy5iYXNlO1xuICAgICAgICAgICAgaWYgKG9sZERvbSAmJiBkb20gIT09IG9sZERvbSkge1xuICAgICAgICAgICAgICAgIG9sZERvbS5fY29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZWNvbGxlY3ROb2RlVHJlZShvbGREb20sICExKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9tO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgICAgICBpZiAob3B0aW9ucy5iZWZvcmVVbm1vdW50KSBvcHRpb25zLmJlZm9yZVVubW91bnQoY29tcG9uZW50KTtcbiAgICAgICAgdmFyIGJhc2UgPSBjb21wb25lbnQuYmFzZTtcbiAgICAgICAgY29tcG9uZW50Ll9feCA9ICEwO1xuICAgICAgICBpZiAoY29tcG9uZW50LmNvbXBvbmVudFdpbGxVbm1vdW50KSBjb21wb25lbnQuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICAgICAgY29tcG9uZW50LmJhc2UgPSBudWxsO1xuICAgICAgICB2YXIgaW5uZXIgPSBjb21wb25lbnQuX2NvbXBvbmVudDtcbiAgICAgICAgaWYgKGlubmVyKSB1bm1vdW50Q29tcG9uZW50KGlubmVyKTsgZWxzZSBpZiAoYmFzZSkge1xuICAgICAgICAgICAgaWYgKGJhc2UuX19wcmVhY3RhdHRyXyAmJiBiYXNlLl9fcHJlYWN0YXR0cl8ucmVmKSBiYXNlLl9fcHJlYWN0YXR0cl8ucmVmKG51bGwpO1xuICAgICAgICAgICAgY29tcG9uZW50Ll9fYiA9IGJhc2U7XG4gICAgICAgICAgICByZW1vdmVOb2RlKGJhc2UpO1xuICAgICAgICAgICAgY29sbGVjdENvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgICAgICAgcmVtb3ZlQ2hpbGRyZW4oYmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBvbmVudC5fX3IpIGNvbXBvbmVudC5fX3IobnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCkge1xuICAgICAgICB0aGlzLl9fZCA9ICEwO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlIHx8IHt9O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXIodm5vZGUsIHBhcmVudCwgbWVyZ2UpIHtcbiAgICAgICAgcmV0dXJuIGRpZmYobWVyZ2UsIHZub2RlLCB7fSwgITEsIHBhcmVudCwgITEpO1xuICAgIH1cbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBFTVBUWV9DSElMRFJFTiA9IFtdO1xuICAgIHZhciBkZWZlciA9ICdmdW5jdGlvbicgPT0gdHlwZW9mIFByb21pc2UgPyBQcm9taXNlLnJlc29sdmUoKS50aGVuLmJpbmQoUHJvbWlzZS5yZXNvbHZlKCkpIDogc2V0VGltZW91dDtcbiAgICB2YXIgSVNfTk9OX0RJTUVOU0lPTkFMID0gL2FjaXR8ZXgoPzpzfGd8bnxwfCQpfHJwaHxvd3N8bW5jfG50d3xpbmVbY2hdfHpvb3xeb3JkL2k7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdmFyIG1vdW50cyA9IFtdO1xuICAgIHZhciBkaWZmTGV2ZWwgPSAwO1xuICAgIHZhciBpc1N2Z01vZGUgPSAhMTtcbiAgICB2YXIgaHlkcmF0aW5nID0gITE7XG4gICAgdmFyIGNvbXBvbmVudHMgPSB7fTtcbiAgICBleHRlbmQoQ29tcG9uZW50LnByb3RvdHlwZSwge1xuICAgICAgICBzZXRTdGF0ZTogZnVuY3Rpb24oc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX19zKSB0aGlzLl9fcyA9IGV4dGVuZCh7fSwgcyk7XG4gICAgICAgICAgICBleHRlbmQocywgJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygc3RhdGUgPyBzdGF0ZShzLCB0aGlzLnByb3BzKSA6IHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgKHRoaXMuX19oID0gdGhpcy5fX2ggfHwgW10pLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgZW5xdWV1ZVJlbmRlcih0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9yY2VVcGRhdGU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spICh0aGlzLl9faCA9IHRoaXMuX19oIHx8IFtdKS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJlbmRlckNvbXBvbmVudCh0aGlzLCAyKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHt9XG4gICAgfSk7XG4gICAgdmFyIHByZWFjdCA9IHtcbiAgICAgICAgaDogaCxcbiAgICAgICAgY3JlYXRlRWxlbWVudDogaCxcbiAgICAgICAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnQsXG4gICAgICAgIENvbXBvbmVudDogQ29tcG9uZW50LFxuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgcmVyZW5kZXI6IHJlcmVuZGVyLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgfTtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIG1vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBwcmVhY3Q7IGVsc2Ugc2VsZi5wcmVhY3QgPSBwcmVhY3Q7XG59KCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVhY3QuanMubWFwIiwiLyohXG4gIENvcHlyaWdodCAoYykgMjAxNyBKZWQgV2F0c29uLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMgKCkge1xuXHRcdHZhciBjbGFzc2VzID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmICghYXJnKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuXG5cdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGFyZyk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSAmJiBhcmcubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBpbm5lciA9IGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKTtcblx0XHRcdFx0aWYgKGlubmVyKSB7XG5cdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGlubmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Y2xhc3NOYW1lcy5kZWZhdWx0ID0gY2xhc3NOYW1lcztcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuIl19
